/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2015-12-28 09:53:57.620027
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[0]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKcos(j[4]);
x11=IKsin(j[4]);
x12=((0.258)*x2);
x13=((0.03)*x2);
x14=((1.0)*x5);
x15=((1.0)*x3);
x16=((0.258)*x3);
x17=((0.006)*x3);
x18=((0.006)*x0);
x19=((1.0)*x10);
x20=((0.123)*x0);
x21=((0.006)*x2);
x22=((0.123)*x6);
x23=((0.03)*x3);
x24=((1.0)*x11);
x25=((0.123)*x2);
x26=((1.0)*x2);
x27=((0.006)*x7);
x28=((1.0)*x7);
x29=(x1*x7);
x30=(x0*x4);
x31=(x11*x6);
x32=(x2*x4);
x33=(x4*x7);
x34=(x0*x1);
x35=(x0*x6);
x36=(x28*x6);
x37=(x14*x7);
x38=(x1*x15);
x39=((0.123)*x3*x4);
x40=(x26*x30);
x41=(x26*x33);
x42=((((-1.0)*x38))+x32);
x43=((((-1.0)*x1*x26))+(((-1.0)*x15*x4)));
x44=(((x1*x26))+((x15*x4)));
x45=((((-1.0)*x40))+((x3*x34)));
x46=(((x29*x3))+(((-1.0)*x41)));
x47=(x43*x6);
x48=(x40+(((-1.0)*x15*x34)));
x49=((((-1.0)*x15*x29))+x41);
x50=((((-1.0)*x26*x34))+(((-1.0)*x15*x30)));
x51=(((x15*x33))+((x26*x29)));
x52=(x45*x6);
x53=(x46*x6);
x54=(x48*x5);
x55=(((x0*x5))+x53);
x56=(((x10*(((((-1.0)*x37))+x52))))+((x11*x50)));
x57=(((x24*x51))+(((-1.0)*x19*x55)));
eerot[0]=(((x9*(((((-1.0)*x36))+x54))))+((x56*x8)));
eerot[1]=(((x56*x9))+((x8*(((((-1.0)*x14*x48))+x36)))));
eerot[2]=(((x10*x50))+((x11*((x37+(((-1.0)*x52)))))));
IkReal x58=((1.0)*x34);
IkReal x59=((1.0)*x20);
eetrans[0]=((0.027)+((x27*x6))+(((-0.264)*x30))+(((-1.0)*x12*x58))+((x5*(((((-1.0)*x18*x32))+((x17*x34))))))+((x10*(((((-1.0)*x1*x2*x59))+(((-1.0)*x3*x4*x59))))))+((x11*(((((0.123)*x5*x7))+(((-1.0)*x22*x45))))))+(((-1.0)*x16*x30))+x27+((x13*x30))+(((-1.0)*x23*x58))+(((0.029998)*x34)));
eerot[3]=(((x9*(((((-1.0)*x35))+(((-1.0)*x14*x49))))))+((x57*x8)));
eerot[4]=(((x57*x9))+((x8*((((x49*x5))+x35)))));
eerot[5]=(((x11*x55))+((x10*x51)));
eetrans[1]=(((x18*x6))+(((0.264)*x33))+((x10*((((x25*x29))+(((0.123)*x3*x33))))))+((x11*((((x22*x46))+((x20*x5))))))+((x16*x33))+((x5*((((x21*x33))+(((-1.0)*x17*x29))))))+((x23*x29))+(((-0.029998)*x29))+x18+((x12*x29))+(((-1.0)*x13*x33)));
eerot[6]=(((x8*(((((-1.0)*x10*x47))+(((-1.0)*x11*x42))))))+((x43*x5*x9)));
eerot[7]=(((x9*(((((-1.0)*x19*x47))+(((-1.0)*x24*x42))))))+((x44*x5*x8)));
eerot[8]=(((x31*x43))+((x10*((x38+(((-1.0)*x26*x4)))))));
IkReal x60=((1.0)*x25);
IkReal x61=((1.0)*x4);
eetrans[2]=((0.102)+(((0.264)*x1))+((x1*x16))+(((-1.0)*x12*x61))+(((-1.0)*x1*x13))+((x10*(((((0.123)*x1*x3))+(((-1.0)*x4*x60))))))+(((-1.0)*x23*x61))+((x31*(((((-1.0)*x39))+(((-1.0)*x1*x60))))))+(((0.029998)*x4))+((x5*((((x1*x21))+((x17*x4)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=((-1.0)*r01);
new_r02=((-1.0)*r02);
new_px=((-0.027)+(((-0.123)*r02))+px);
new_r10=((-1.0)*r10);
new_r11=r11;
new_r12=r12;
new_py=((((0.123)*r12))+(((-1.0)*py)));
new_r20=((-1.0)*r20);
new_r21=r21;
new_r22=r22;
new_pz=((0.102)+(((-1.0)*pz))+(((0.123)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x62=((1.0)*px);
IkReal x63=((1.0)*pz);
IkReal x64=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x64))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x63)));
rxp0_2=((((-1.0)*r10*x62))+((py*r00)));
rxp1_0=((((-1.0)*r21*x64))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x63)));
rxp1_2=((((-1.0)*r11*x62))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x64)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x63)));
rxp2_2=((((-1.0)*r12*x62))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x65=((1.0)*r02);
IkReal x66=((0.006)*r20);
IkReal x67=((0.006)*r02);
IkReal x68=((1.0)*rxp2_2);
IkReal x69=((0.006)*r22);
IkReal x70=((0.006)*r00);
IkReal x71=((1.0)*rxp2_0);
IkReal x72=((8.6)*npz);
IkReal x73=((16.6666666666667)*pp);
IkReal x74=((0.006)*r10);
IkReal x75=((0.2)*npy);
IkReal x76=((1.0)*rxp2_1);
IkReal x77=((2.0)*r00);
IkReal x78=((0.012)*r22);
IkReal x79=((2.0)*rxp0_2);
IkReal x80=((0.012)*r00);
IkReal x81=((0.012)*r02);
IkReal x82=((0.012)*r20);
IkReal x83=((2.0)*rxp0_0);
IkReal x84=((17.2)*npx);
IkReal x85=((0.012)*r12);
IkReal x86=((2.0)*rxp0_1);
IkReal x87=(cj3*r21);
IkReal x88=(r20*sj3);
IkReal x89=(r21*sj3);
IkReal x90=(cj3*r20);
IkReal x91=((0.006)*r12);
IkReal x92=((0.012)*r11);
IkReal x93=((0.4)*npx);
IkReal x94=((2.0)*cj3);
IkReal x95=((-1.0)*r12);
IkReal x96=((-0.006)*r12);
IkReal x97=((2.0)*r22*sj3);
IkReal x98=(r22*x94);
IkReal x99=((1.0)*x88);
IkReal x100=((2.0)*x90);
IkReal x101=((2.0)*x89);
IkReal x102=((1.0)*x87);
IkReal x103=((2.0)*x88);
IkReal x104=((2.0)*x87);
IkReal x105=((1.0)*x89);
IkReal x106=((1.0)*x90);
IkReal x107=((-0.0521980000666667)+x73);
IkReal x108=(x70+x69);
IkReal x109=(x79+x80);
IkReal x110=(x75+x72);
IkReal x111=(x66+x67);
op[0]=(x88+x87);
op[1]=0;
op[2]=((((-1.0)*x101))+x100);
op[3]=0;
op[4]=((((-1.0)*x102))+(((-1.0)*x99)));
op[5]=0;
op[6]=((((-1.0)*x106))+x89+(((-1.0)*x65)));
op[7]=x95;
op[8]=(x104+x103);
op[9]=0;
op[10]=((((-1.0)*x105))+x90+(((-1.0)*x65)));
op[11]=x95;
op[12]=(x66+(((-1.0)*x68))+(((-1.0)*x67)));
op[13]=x96;
op[14]=((-0.012)*r21);
op[15]=0;
op[16]=((((-1.0)*x111))+(((-1.0)*x68)));
op[17]=x96;
op[18]=((((-1.0)*x71))+x108);
op[19]=((((-1.0)*x76))+x110+x107+x74);
op[20]=((-0.012)*r01);
op[21]=(x93+(((-1.0)*x92)));
op[22]=((((-1.0)*x71))+(((-1.0)*x70))+x69);
op[23]=((((-1.0)*x74))+(((-1.0)*x75))+(((-1.0)*x76))+x107+x72);
op[24]=x97;
op[25]=0;
op[26]=0;
op[27]=0;
op[28]=x97;
op[29]=0;
op[30]=(x77+(((-1.0)*x98)));
op[31]=((2.0)*r10);
op[32]=((-4.0)*r01);
op[33]=((-4.0)*r11);
op[34]=((((-1.0)*x77))+(((-1.0)*x98)));
op[35]=((-2.0)*r10);
op[36]=(x109+x78);
op[37]=((0.012)*r10);
op[38]=((((-0.024)*r01))+(((-4.0)*rxp1_2)));
op[39]=((-0.024)*r11);
op[40]=((((-1.0)*x109))+x78);
op[41]=((-0.012)*r10);
op[42]=(x83+x81+(((-1.0)*x82)));
op[43]=(x86+x85+(((-1.0)*x84)));
op[44]=((((-4.0)*rxp1_0))+(((0.024)*r21)));
op[45]=((((-4.0)*rxp1_1))+(((34.4)*npy)));
op[46]=(x82+x81+(((-1.0)*x83)));
op[47]=(x84+x85+(((-1.0)*x86)));
op[48]=(x87+(((-1.0)*x99)));
op[49]=0;
op[50]=(x100+x101);
op[51]=0;
op[52]=((((-1.0)*x102))+x88);
op[53]=0;
op[54]=(x89+x90+r02);
op[55]=r12;
op[56]=((((-1.0)*x104))+x103);
op[57]=0;
op[58]=((((-1.0)*x106))+(((-1.0)*x105))+r02);
op[59]=r12;
op[60]=(rxp2_2+x67+(((-1.0)*x66)));
op[61]=x91;
op[62]=((0.012)*r21);
op[63]=0;
op[64]=(rxp2_2+x111);
op[65]=x91;
op[66]=(rxp2_0+(((-1.0)*x108)));
op[67]=((((-1.0)*x72))+(((-1.0)*x74))+rxp2_1+x107+x75);
op[68]=((0.012)*r01);
op[69]=(x93+x92);
op[70]=(rxp2_0+x70+(((-1.0)*x69)));
op[71]=(rxp2_1+(((-1.0)*x110))+x107+x74);
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x112=htj4*htj4;
CheckValue<IkReal> x113=IKPowWithIntegerCheck(((1.0)+x112),-1);
if(!x113.valid){
continue;
}
cj4array[numsolutions]=((x113.value)*(((1.0)+(((-1.0)*x112)))));
CheckValue<IkReal> x114=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x114.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x114.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x115=htj5*htj5;
CheckValue<IkReal> x116=IKPowWithIntegerCheck(((1.0)+x115),-1);
if(!x116.valid){
continue;
}
cj5array[numsolutions]=((x116.value)*(((1.0)+(((-1.0)*x115)))));
CheckValue<IkReal> x117=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x117.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x117.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x118=htj0*htj0;
CheckValue<IkReal> x119=IKPowWithIntegerCheck(((1.0)+x118),-1);
if(!x119.valid){
continue;
}
cj0array[numsolutions]=((x119.value)*(((1.0)+(((-1.0)*x118)))));
CheckValue<IkReal> x120=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x120.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x120.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[3];
IkReal x121=((1.0)*cj0);
IkReal x122=((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5)));
j3eval[0]=x122;
j3eval[1]=IKsign(x122);
j3eval[2]=((IKabs((((cj0*cj4*cj5*r20))+(((-1.0)*cj4*r21*sj5*x121))+((cj0*r22*sj4)))))+(IKabs(((((-1.0)*r20*sj5*x121))+(((-1.0)*cj5*r21*x121))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
IkReal x123=((1.0)*sj5);
IkReal x124=(r20*sj0);
IkReal x125=((1.0)*r21*sj0);
IkReal x126=(((cj5*r10*sj4))+(((-1.0)*r11*sj4*x123))+(((-1.0)*cj4*r12)));
j3eval[0]=x126;
j3eval[1]=((IKabs(((((-1.0)*x123*x124))+(((-1.0)*cj5*x125)))))+(IKabs(((((-1.0)*cj4*r21*sj0*x123))+((r22*sj0*sj4))+((cj4*cj5*x124))))));
j3eval[2]=IKsign(x126);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x127=(((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)));
j3eval[0]=x127;
j3eval[1]=IKsign(x127);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=(((cj5*r10*sj4))+(((-1.0)*r11*sj4*sj5))+(((-1.0)*cj4*r12)));
evalcond[2]=((-0.006)+(((-1.0)*py))+(((-0.006)*r10*sj5))+(((-0.006)*cj5*r11)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x128=((1.0)*cj5);
IkReal x129=((1.0)*sj5);
IkReal x130=(((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*r20*sj4*x128)));
j3eval[0]=x130;
j3eval[1]=((IKabs(((((-1.0)*r00*x129))+(((-1.0)*r01*x128)))))+(IKabs((((r02*sj4))+((cj4*cj5*r00))+(((-1.0)*cj4*r01*x129))))));
j3eval[2]=IKsign(x130);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x131=((1.0)*sj5);
IkReal x132=((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*x131)));
j3eval[0]=x132;
j3eval[1]=((IKabs(((((-1.0)*cj5*r21))+(((-1.0)*r20*x131)))))+(IKabs((((r22*sj4))+(((-1.0)*cj4*r21*x131))+((cj4*cj5*r20))))));
j3eval[2]=IKsign(x132);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x133=cj4*cj4;
IkReal x134=cj5*cj5;
IkReal x135=r10*r10;
IkReal x136=r11*r11;
IkReal x137=r12*r12;
IkReal x138=(r11*sj5);
IkReal x139=((1.0)*r10);
IkReal x140=(r12*sj4);
IkReal x141=((1.0)*x135);
IkReal x142=((2.0)*cj5*r10);
IkReal x143=(x134*x136);
IkReal x144=((((-1.0)*x141))+(((2.0)*cj4*x138*x140))+(((-1.0)*x138*x142))+(((-1.0)*x133*x134*x141))+(((-1.0)*cj4*x140*x142))+((x134*x135))+(((-1.0)*x143))+(((-1.0)*x133*x136))+((x133*x137))+(((-1.0)*x137))+((x133*x138*x142))+((x133*x143)));
j3eval[0]=x144;
j3eval[1]=IKsign(x144);
j3eval[2]=((IKabs(((((-1.0)*cj4*cj5*x139))+(((-1.0)*x140))+((cj4*x138)))))+(IKabs(((((-1.0)*cj5*r11))+(((-1.0)*sj5*x139))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x145=cj4*cj4;
IkReal x146=cj5*cj5;
IkReal x147=r10*r10;
IkReal x148=r11*r11;
IkReal x149=r12*r12;
IkReal x150=(r11*sj5);
IkReal x151=((1.0)*cj5);
IkReal x152=(r12*sj4);
IkReal x153=((1.0)*x147);
IkReal x154=((2.0)*cj5*r10);
IkReal x155=(x146*x148);
CheckValue<IkReal> x156 = IKatan2WithCheck(IkReal((((cj4*x150))+(((-1.0)*x152))+(((-1.0)*cj4*r10*x151)))),((((-1.0)*r10*sj5))+(((-1.0)*r11*x151))),IKFAST_ATAN2_MAGTHRESH);
if(!x156.valid){
continue;
}
CheckValue<IkReal> x157=IKPowWithIntegerCheck(IKsign(((((2.0)*cj4*x150*x152))+(((-1.0)*x153))+((x145*x150*x154))+(((-1.0)*cj4*x152*x154))+(((-1.0)*x150*x154))+((x145*x149))+((x145*x155))+(((-1.0)*x155))+(((-1.0)*x149))+(((-1.0)*x145*x148))+((x146*x147))+(((-1.0)*x145*x146*x153)))),-1);
if(!x157.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x156.value)+(((1.5707963267949)*(x157.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x158=IKsin(j3);
IkReal x159=IKcos(j3);
IkReal x160=(r10*sj5);
IkReal x161=(cj4*sj5);
IkReal x162=(cj5*r11);
IkReal x163=(cj4*cj5);
IkReal x164=(r12*sj4);
IkReal x165=((1.0)*x159);
IkReal x166=((1.0)*x158);
evalcond[0]=((((-1.0)*r10*x163*x165))+((r11*x159*x161))+((x158*x162))+((x158*x160))+(((-1.0)*x164*x165)));
evalcond[1]=((((-1.0)*r20*sj5*x165))+(((-1.0)*r20*x163*x166))+(((-1.0)*cj5*r21*x165))+((r21*x158*x161))+(((-1.0)*r22*sj4*x166)));
evalcond[2]=(((r01*x158*x161))+(((-1.0)*r02*sj4*x166))+(((-1.0)*cj5*r01*x165))+(((-1.0)*r00*sj5*x165))+(((-1.0)*r00*x163*x166)));
evalcond[3]=((1.0)+(((-1.0)*x160*x165))+(((-1.0)*r10*x163*x166))+((r11*x158*x161))+(((-1.0)*x162*x165))+(((-1.0)*x164*x166)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x167=(r00*sj5);
IkReal x168=(cj4*r22);
IkReal x169=(cj5*r01);
IkReal x170=(r20*sj5);
IkReal x171=(cj5*r21);
IkReal x172=(r21*sj4*sj5);
IkReal x173=(cj5*r20*sj4);
IkReal x174=((0.809568)*x173);
IkReal x175=((((0.809568)*x172))+(((0.018576)*x171))+(((0.018576)*x170))+(((0.36)*px))+(((0.00216)*x169))+(((0.00216)*x167))+(((0.809568)*x168))+(((3.096)*pz)));
j1eval[0]=((1.0)+(((1.99559576803425)*(IKabs(((-0.26884824)+(((-1.0)*x175))+x174)))))+(((1.99559576803425)*(IKabs(((0.26884824)+(((-0.269856)*x172))+(((-0.00072)*x169))+(((-0.00072)*x167))+(((-0.269856)*x168))+(((0.269856)*x173))+(((-0.006192)*x171))+(((-0.006192)*x170))+(((-0.12)*px))+(((-1.032)*pz)))))))+(((1.99559576803425)*(IKabs(((0.26884824)+(((-1.0)*x175))+x174))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x176=(r00*sj5);
IkReal x177=(cj4*r22);
IkReal x178=(cj5*r01);
IkReal x179=(r20*sj5);
IkReal x180=(cj5*r21);
IkReal x181=(r21*sj4*sj5);
IkReal x182=(cj5*r20*sj4);
IkReal x183=((0.809568)*x182);
IkReal x184=((0.269856)*x182);
IkReal x185=((((0.809568)*x177))+(((0.809568)*x181))+(((0.00216)*x176))+(((0.00216)*x178))+(((0.018576)*x180))+(((0.018576)*x179))+(((0.36)*px))+(((3.096)*pz)));
IkReal x186=((((0.12)*px))+(((0.00072)*x176))+(((0.00072)*x178))+(((0.269856)*x177))+(((1.032)*pz))+(((0.269856)*x181))+(((0.006192)*x180))+(((0.006192)*x179)));
op[0]=((0.26884824)+(((-1.0)*x186))+x184);
op[1]=-0.125275872;
op[2]=((0.26884824)+(((-1.0)*x185))+x183);
op[3]=-0.250551744;
op[4]=((-0.26884824)+(((-1.0)*x185))+x183);
op[5]=-0.125275872;
op[6]=((-0.26884824)+(((-1.0)*x186))+x184);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x187=((0.36)*pz);
IkReal x188=((0.12)*pz);
IkReal x189=((1.032)*px);
IkReal x190=((0.269856)*sj4);
IkReal x191=(cj5*r00);
IkReal x192=(cj5*r01);
IkReal x193=(r00*sj5);
IkReal x194=(cj5*r21);
IkReal x195=(r01*sj5);
IkReal x196=(cj4*r02);
IkReal x197=((0.809568)*sj4);
IkReal x198=(r20*sj5);
IkReal x199=((0.00216)*x198);
IkReal x200=((0.00216)*x194);
IkReal x201=((0.00072)*x194);
IkReal x202=((0.00072)*x198);
IkReal x203=((0.269856)*x196);
IkReal x204=((0.006192)*x192);
IkReal x205=((0.006192)*x193);
IkReal x206=(x191*x197);
IkReal x207=(x190*x191);
IkReal x208=(x190*x195);
IkReal x209=(x188+x207+x202+x201);
IkReal x210=(x199+x187+x206+x200);
IkReal x211=((((0.809568)*x196))+(((0.018576)*x193))+(((0.018576)*x192))+((x195*x197))+(((3.096)*px)));
IkReal x212=(x189+x205+x204+x203+x208);
j1evalpoly[0]=((0.062637936)+(((htj1*htj1*htj1*htj1)*(((-0.062637936)+x210+(((-1.0)*x211))))))+x209+(((htj1*htj1)*(((0.062637936)+x210+(((-1.0)*x211))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.062637936)+x209+(((-1.0)*x212))))))+(((-0.53769648)*htj1))+(((-1.07539296)*(htj1*htj1*htj1)))+(((-1.0)*x212))+(((-0.53769648)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x213=(cj4*sj1);
IkReal x214=(cj1*sj4);
IkReal x215=((1.0)*cj5);
IkReal x216=(r21*sj5);
IkReal x217=(cj1*cj4);
IkReal x218=(sj1*sj4);
IkReal x219=(r01*sj4*sj5);
if( IKabs(((((-1.0)*x216*x218))+(((-1.0)*r22*x213))+(((-1.0)*r00*x214*x215))+((r02*x217))+((r01*sj5*x214))+((cj5*r20*x218)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x214*x216))+(((-1.0)*r00*x215*x218))+((r02*x213))+((r01*sj5*x218))+((r22*x217))+(((-1.0)*r20*x214*x215)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x216*x218))+(((-1.0)*r22*x213))+(((-1.0)*r00*x214*x215))+((r02*x217))+((r01*sj5*x214))+((cj5*r20*x218))))+IKsqr((((x214*x216))+(((-1.0)*r00*x215*x218))+((r02*x213))+((r01*sj5*x218))+((r22*x217))+(((-1.0)*r20*x214*x215))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x216*x218))+(((-1.0)*r22*x213))+(((-1.0)*r00*x214*x215))+((r02*x217))+((r01*sj5*x214))+((cj5*r20*x218))), (((x214*x216))+(((-1.0)*r00*x215*x218))+((r02*x213))+((r01*sj5*x218))+((r22*x217))+(((-1.0)*r20*x214*x215))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x220=IKcos(j2);
IkReal x221=IKsin(j2);
IkReal x222=((0.258)*sj1);
IkReal x223=((1.0)*cj3);
IkReal x224=(cj5*r00);
IkReal x225=(cj5*r01);
IkReal x226=(cj5*r21);
IkReal x227=(cj5*r20);
IkReal x228=(r00*sj5);
IkReal x229=((1.0)*cj4);
IkReal x230=(r20*sj5);
IkReal x231=(cj1*x220);
IkReal x232=(cj3*cj4*sj5);
IkReal x233=(sj1*x220);
IkReal x234=((1.0)*sj4*sj5);
IkReal x235=(cj1*x221);
IkReal x236=(sj1*x221);
IkReal x237=((1.0)*x236);
evalcond[0]=(((sj4*x224))+(((-1.0)*r02*x229))+x233+x235+(((-1.0)*r01*x234)));
evalcond[1]=(((sj4*x227))+(((-1.0)*x237))+x231+(((-1.0)*r21*x234))+(((-1.0)*r22*x229)));
evalcond[2]=((((-1.0)*r02*sj4*x223))+(((-1.0)*cj4*x223*x224))+(((-1.0)*x237))+x231+((r01*x232))+((sj3*x228))+((sj3*x225)));
evalcond[3]=((((-1.0)*cj4*x223*x227))+(((-1.0)*r22*sj4*x223))+((sj3*x226))+((r21*x232))+(((-1.0)*x235))+(((-1.0)*x233))+((sj3*x230)));
evalcond[4]=((((-0.258)*x231))+(((0.03)*x233))+(((0.03)*x235))+(((-0.029998)*sj1))+(((-0.006)*x226))+(((-1.0)*pz))+(((-0.264)*cj1))+((x221*x222))+(((-0.006)*x230)));
evalcond[5]=((((-0.03)*x231))+(((-0.258)*x235))+(((0.03)*x236))+(((-0.006)*x225))+(((-0.006)*x228))+(((0.029998)*cj1))+(((-0.264)*sj1))+(((-1.0)*px))+(((-1.0)*x220*x222)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x238=((1.0)*sj5);
CheckValue<IkReal> x239=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*x238)))),-1);
if(!x239.valid){
continue;
}
CheckValue<IkReal> x240 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x238))+(((-1.0)*cj5*r21)))),(((r22*sj4))+(((-1.0)*cj4*r21*x238))+((cj4*cj5*r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x240.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x239.value)))+(x240.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x241=IKsin(j3);
IkReal x242=IKcos(j3);
IkReal x243=(r10*sj5);
IkReal x244=(cj4*sj5);
IkReal x245=(cj5*r11);
IkReal x246=(cj4*cj5);
IkReal x247=(r12*sj4);
IkReal x248=((1.0)*x242);
IkReal x249=((1.0)*x241);
evalcond[0]=((((-1.0)*r10*x246*x248))+((x241*x245))+((x241*x243))+((r11*x242*x244))+(((-1.0)*x247*x248)));
evalcond[1]=((((-1.0)*r20*sj5*x248))+(((-1.0)*cj5*r21*x248))+(((-1.0)*r22*sj4*x249))+(((-1.0)*r20*x246*x249))+((r21*x241*x244)));
evalcond[2]=((((-1.0)*r02*sj4*x249))+(((-1.0)*r00*sj5*x248))+(((-1.0)*cj5*r01*x248))+((r01*x241*x244))+(((-1.0)*r00*x246*x249)));
evalcond[3]=((1.0)+(((-1.0)*x243*x248))+(((-1.0)*r10*x246*x249))+(((-1.0)*x245*x248))+((r11*x241*x244))+(((-1.0)*x247*x249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x250=(r00*sj5);
IkReal x251=(cj4*r22);
IkReal x252=(cj5*r01);
IkReal x253=(r20*sj5);
IkReal x254=(cj5*r21);
IkReal x255=(r21*sj4*sj5);
IkReal x256=(cj5*r20*sj4);
IkReal x257=((0.809568)*x256);
IkReal x258=((((0.00216)*x250))+(((0.00216)*x252))+(((0.36)*px))+(((0.018576)*x254))+(((0.018576)*x253))+(((3.096)*pz))+(((0.809568)*x251))+(((0.809568)*x255)));
j1eval[0]=((1.0)+(((1.99559576803425)*(IKabs(((-0.26884824)+x257+(((-1.0)*x258)))))))+(((1.99559576803425)*(IKabs(((0.26884824)+(((-0.269856)*x251))+(((-0.269856)*x255))+(((0.269856)*x256))+(((-0.00072)*x250))+(((-0.00072)*x252))+(((-0.12)*px))+(((-0.006192)*x253))+(((-0.006192)*x254))+(((-1.032)*pz)))))))+(((1.99559576803425)*(IKabs(((0.26884824)+x257+(((-1.0)*x258))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x259=(r00*sj5);
IkReal x260=(cj4*r22);
IkReal x261=(cj5*r01);
IkReal x262=(r20*sj5);
IkReal x263=(cj5*r21);
IkReal x264=(r21*sj4*sj5);
IkReal x265=(cj5*r20*sj4);
IkReal x266=((0.809568)*x265);
IkReal x267=((0.269856)*x265);
IkReal x268=((((0.00216)*x259))+(((0.36)*px))+(((0.018576)*x263))+(((0.018576)*x262))+(((0.809568)*x260))+(((0.809568)*x264))+(((0.00216)*x261))+(((3.096)*pz)));
IkReal x269=((((0.12)*px))+(((0.269856)*x264))+(((0.269856)*x260))+(((0.00072)*x259))+(((1.032)*pz))+(((0.006192)*x262))+(((0.006192)*x263))+(((0.00072)*x261)));
op[0]=((0.26884824)+x267+(((-1.0)*x269)));
op[1]=-0.125275872;
op[2]=((0.26884824)+x266+(((-1.0)*x268)));
op[3]=-0.250551744;
op[4]=((-0.26884824)+x266+(((-1.0)*x268)));
op[5]=-0.125275872;
op[6]=((-0.26884824)+x267+(((-1.0)*x269)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x270=((0.36)*pz);
IkReal x271=((0.12)*pz);
IkReal x272=((1.032)*px);
IkReal x273=((0.269856)*sj4);
IkReal x274=(cj5*r00);
IkReal x275=(cj5*r01);
IkReal x276=(r00*sj5);
IkReal x277=(cj5*r21);
IkReal x278=(r01*sj5);
IkReal x279=(cj4*r02);
IkReal x280=((0.809568)*sj4);
IkReal x281=(r20*sj5);
IkReal x282=((0.00216)*x281);
IkReal x283=((0.00216)*x277);
IkReal x284=((0.00072)*x277);
IkReal x285=((0.00072)*x281);
IkReal x286=((0.269856)*x279);
IkReal x287=((0.006192)*x275);
IkReal x288=((0.006192)*x276);
IkReal x289=(x274*x280);
IkReal x290=(x273*x274);
IkReal x291=(x273*x278);
IkReal x292=(x290+x271+x285+x284);
IkReal x293=(x270+x289+x283+x282);
IkReal x294=(((x278*x280))+(((0.018576)*x276))+(((0.018576)*x275))+(((0.809568)*x279))+(((3.096)*px)));
IkReal x295=(x291+x272+x288+x287+x286);
j1evalpoly[0]=((0.062637936)+(((htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x294))+x293))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x295))+x292))))+(((-1.0)*x295))+(((htj1*htj1)*(((0.062637936)+(((-1.0)*x294))+x293))))+x292+(((-0.53769648)*htj1))+(((-1.07539296)*(htj1*htj1*htj1)))+(((-0.53769648)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x296=(cj4*sj1);
IkReal x297=(cj1*sj4);
IkReal x298=((1.0)*cj5);
IkReal x299=(r21*sj5);
IkReal x300=(cj1*cj4);
IkReal x301=(sj1*sj4);
IkReal x302=(r01*sj4*sj5);
if( IKabs((((cj5*r20*x301))+((r01*sj5*x297))+(((-1.0)*r22*x296))+(((-1.0)*r00*x297*x298))+((r02*x300))+(((-1.0)*x299*x301)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r22*x300))+((r01*sj5*x301))+(((-1.0)*r20*x297*x298))+((x297*x299))+(((-1.0)*r00*x298*x301))+((r02*x296)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj5*r20*x301))+((r01*sj5*x297))+(((-1.0)*r22*x296))+(((-1.0)*r00*x297*x298))+((r02*x300))+(((-1.0)*x299*x301))))+IKsqr((((r22*x300))+((r01*sj5*x301))+(((-1.0)*r20*x297*x298))+((x297*x299))+(((-1.0)*r00*x298*x301))+((r02*x296))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj5*r20*x301))+((r01*sj5*x297))+(((-1.0)*r22*x296))+(((-1.0)*r00*x297*x298))+((r02*x300))+(((-1.0)*x299*x301))), (((r22*x300))+((r01*sj5*x301))+(((-1.0)*r20*x297*x298))+((x297*x299))+(((-1.0)*r00*x298*x301))+((r02*x296))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x303=IKcos(j2);
IkReal x304=IKsin(j2);
IkReal x305=((0.258)*sj1);
IkReal x306=((1.0)*cj3);
IkReal x307=(cj5*r00);
IkReal x308=(cj5*r01);
IkReal x309=(cj5*r21);
IkReal x310=(cj5*r20);
IkReal x311=(r00*sj5);
IkReal x312=((1.0)*cj4);
IkReal x313=(r20*sj5);
IkReal x314=(cj1*x303);
IkReal x315=(cj3*cj4*sj5);
IkReal x316=(sj1*x303);
IkReal x317=((1.0)*sj4*sj5);
IkReal x318=(cj1*x304);
IkReal x319=(sj1*x304);
IkReal x320=((1.0)*x319);
evalcond[0]=((((-1.0)*r02*x312))+(((-1.0)*r01*x317))+x318+x316+((sj4*x307)));
evalcond[1]=((((-1.0)*r21*x317))+(((-1.0)*x320))+((sj4*x310))+x314+(((-1.0)*r22*x312)));
evalcond[2]=(((sj3*x308))+(((-1.0)*x320))+(((-1.0)*r02*sj4*x306))+x314+((r01*x315))+((sj3*x311))+(((-1.0)*cj4*x306*x307)));
evalcond[3]=((((-1.0)*r22*sj4*x306))+((sj3*x309))+(((-1.0)*cj4*x306*x310))+(((-1.0)*x316))+(((-1.0)*x318))+((sj3*x313))+((r21*x315)));
evalcond[4]=((((-0.006)*x309))+(((-0.258)*x314))+(((-0.029998)*sj1))+(((-1.0)*pz))+(((-0.264)*cj1))+((x304*x305))+(((-0.006)*x313))+(((0.03)*x318))+(((0.03)*x316)));
evalcond[5]=((((-0.006)*x308))+(((-0.03)*x314))+(((-0.258)*x318))+(((0.029998)*cj1))+(((-1.0)*x303*x305))+(((-0.264)*sj1))+(((-1.0)*px))+(((-0.006)*x311))+(((0.03)*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x321=((1.0)*r01);
CheckValue<IkReal> x322=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)))),-1);
if(!x322.valid){
continue;
}
CheckValue<IkReal> x323 = IKatan2WithCheck(IkReal(((((-1.0)*r00*sj5))+(((-1.0)*cj5*x321)))),((((-1.0)*cj4*sj5*x321))+((r02*sj4))+((cj4*cj5*r00))),IKFAST_ATAN2_MAGTHRESH);
if(!x323.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x322.value)))+(x323.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x324=IKsin(j3);
IkReal x325=IKcos(j3);
IkReal x326=(r10*sj5);
IkReal x327=(cj4*sj5);
IkReal x328=(cj5*r11);
IkReal x329=(cj4*cj5);
IkReal x330=(r12*sj4);
IkReal x331=((1.0)*x325);
IkReal x332=((1.0)*x324);
evalcond[0]=((((-1.0)*x330*x331))+((x324*x328))+((x324*x326))+(((-1.0)*r10*x329*x331))+((r11*x325*x327)));
evalcond[1]=((((-1.0)*cj5*r21*x331))+(((-1.0)*r20*sj5*x331))+(((-1.0)*r22*sj4*x332))+(((-1.0)*r20*x329*x332))+((r21*x324*x327)));
evalcond[2]=((((-1.0)*r00*sj5*x331))+(((-1.0)*r02*sj4*x332))+(((-1.0)*r00*x329*x332))+(((-1.0)*cj5*r01*x331))+((r01*x324*x327)));
evalcond[3]=((1.0)+((r11*x324*x327))+(((-1.0)*x328*x331))+(((-1.0)*x330*x332))+(((-1.0)*r10*x329*x332))+(((-1.0)*x326*x331)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x333=(r00*sj5);
IkReal x334=(cj4*r22);
IkReal x335=(cj5*r01);
IkReal x336=(r20*sj5);
IkReal x337=(cj5*r21);
IkReal x338=(r21*sj4*sj5);
IkReal x339=(cj5*r20*sj4);
IkReal x340=((0.809568)*x339);
IkReal x341=((((0.809568)*x334))+(((0.809568)*x338))+(((0.018576)*x337))+(((0.018576)*x336))+(((0.36)*px))+(((0.00216)*x333))+(((0.00216)*x335))+(((3.096)*pz)));
j1eval[0]=((1.0)+(((1.99559576803425)*(IKabs(((0.26884824)+x340+(((-1.0)*x341)))))))+(((1.99559576803425)*(IKabs(((-0.26884824)+x340+(((-1.0)*x341)))))))+(((1.99559576803425)*(IKabs(((0.26884824)+(((-0.269856)*x334))+(((-0.269856)*x338))+(((0.269856)*x339))+(((-0.00072)*x333))+(((-0.00072)*x335))+(((-0.12)*px))+(((-0.006192)*x337))+(((-0.006192)*x336))+(((-1.032)*pz))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x342=(r00*sj5);
IkReal x343=(cj4*r22);
IkReal x344=(cj5*r01);
IkReal x345=(r20*sj5);
IkReal x346=(cj5*r21);
IkReal x347=(r21*sj4*sj5);
IkReal x348=(cj5*r20*sj4);
IkReal x349=((0.809568)*x348);
IkReal x350=((0.269856)*x348);
IkReal x351=((((0.36)*px))+(((0.00216)*x342))+(((0.00216)*x344))+(((0.809568)*x347))+(((0.809568)*x343))+(((0.018576)*x346))+(((0.018576)*x345))+(((3.096)*pz)));
IkReal x352=((((0.12)*px))+(((0.00072)*x342))+(((0.00072)*x344))+(((0.269856)*x343))+(((0.269856)*x347))+(((1.032)*pz))+(((0.006192)*x346))+(((0.006192)*x345)));
op[0]=((0.26884824)+(((-1.0)*x352))+x350);
op[1]=-0.125275872;
op[2]=((0.26884824)+(((-1.0)*x351))+x349);
op[3]=-0.250551744;
op[4]=((-0.26884824)+(((-1.0)*x351))+x349);
op[5]=-0.125275872;
op[6]=((-0.26884824)+(((-1.0)*x352))+x350);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x353=((0.36)*pz);
IkReal x354=((0.12)*pz);
IkReal x355=((1.032)*px);
IkReal x356=((0.269856)*sj4);
IkReal x357=(cj5*r00);
IkReal x358=(cj5*r01);
IkReal x359=(r00*sj5);
IkReal x360=(cj5*r21);
IkReal x361=(r01*sj5);
IkReal x362=(cj4*r02);
IkReal x363=((0.809568)*sj4);
IkReal x364=(r20*sj5);
IkReal x365=((0.00216)*x364);
IkReal x366=((0.00216)*x360);
IkReal x367=((0.00072)*x360);
IkReal x368=((0.00072)*x364);
IkReal x369=((0.269856)*x362);
IkReal x370=((0.006192)*x358);
IkReal x371=((0.006192)*x359);
IkReal x372=(x357*x363);
IkReal x373=(x356*x357);
IkReal x374=(x356*x361);
IkReal x375=(x354+x373+x368+x367);
IkReal x376=(x353+x372+x365+x366);
IkReal x377=((((0.018576)*x359))+(((0.018576)*x358))+((x361*x363))+(((0.809568)*x362))+(((3.096)*px)));
IkReal x378=(x355+x374+x371+x370+x369);
j1evalpoly[0]=((0.062637936)+(((-1.0)*x378))+(((htj1*htj1)*(((0.062637936)+(((-1.0)*x377))+x376))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x378))+x375))))+x375+(((htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x377))+x376))))+(((-0.53769648)*htj1))+(((-1.07539296)*(htj1*htj1*htj1)))+(((-0.53769648)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x379=(cj4*sj1);
IkReal x380=(cj1*sj4);
IkReal x381=((1.0)*cj5);
IkReal x382=(r21*sj5);
IkReal x383=(cj1*cj4);
IkReal x384=(sj1*sj4);
IkReal x385=(r01*sj4*sj5);
if( IKabs(((((-1.0)*x382*x384))+(((-1.0)*r00*x380*x381))+((r02*x383))+((cj5*r20*x384))+(((-1.0)*r22*x379))+((r01*sj5*x380)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*x381*x384))+((r22*x383))+((r02*x379))+(((-1.0)*r20*x380*x381))+((x380*x382))+((r01*sj5*x384)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x382*x384))+(((-1.0)*r00*x380*x381))+((r02*x383))+((cj5*r20*x384))+(((-1.0)*r22*x379))+((r01*sj5*x380))))+IKsqr(((((-1.0)*r00*x381*x384))+((r22*x383))+((r02*x379))+(((-1.0)*r20*x380*x381))+((x380*x382))+((r01*sj5*x384))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x382*x384))+(((-1.0)*r00*x380*x381))+((r02*x383))+((cj5*r20*x384))+(((-1.0)*r22*x379))+((r01*sj5*x380))), ((((-1.0)*r00*x381*x384))+((r22*x383))+((r02*x379))+(((-1.0)*r20*x380*x381))+((x380*x382))+((r01*sj5*x384))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x386=IKcos(j2);
IkReal x387=IKsin(j2);
IkReal x388=((0.258)*sj1);
IkReal x389=((1.0)*cj3);
IkReal x390=(cj5*r00);
IkReal x391=(cj5*r01);
IkReal x392=(cj5*r21);
IkReal x393=(cj5*r20);
IkReal x394=(r00*sj5);
IkReal x395=((1.0)*cj4);
IkReal x396=(r20*sj5);
IkReal x397=(cj1*x386);
IkReal x398=(cj3*cj4*sj5);
IkReal x399=(sj1*x386);
IkReal x400=((1.0)*sj4*sj5);
IkReal x401=(cj1*x387);
IkReal x402=(sj1*x387);
IkReal x403=((1.0)*x402);
evalcond[0]=((((-1.0)*r02*x395))+x399+x401+(((-1.0)*r01*x400))+((sj4*x390)));
evalcond[1]=((((-1.0)*r21*x400))+x397+(((-1.0)*r22*x395))+(((-1.0)*x403))+((sj4*x393)));
evalcond[2]=((((-1.0)*cj4*x389*x390))+((r01*x398))+x397+(((-1.0)*r02*sj4*x389))+((sj3*x394))+((sj3*x391))+(((-1.0)*x403)));
evalcond[3]=((((-1.0)*r22*sj4*x389))+(((-1.0)*x399))+(((-1.0)*cj4*x389*x393))+((sj3*x396))+((sj3*x392))+((r21*x398))+(((-1.0)*x401)));
evalcond[4]=(((x387*x388))+(((-0.258)*x397))+(((-0.029998)*sj1))+(((-1.0)*pz))+(((0.03)*x399))+(((-0.264)*cj1))+(((-0.006)*x392))+(((-0.006)*x396))+(((0.03)*x401)));
evalcond[5]=((((0.029998)*cj1))+(((-0.264)*sj1))+(((-1.0)*px))+(((-1.0)*x386*x388))+(((-0.006)*x394))+(((-0.006)*x391))+(((-0.258)*x401))+(((0.03)*x402))+(((-0.03)*x397)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=(((cj5*r10*sj4))+(((-1.0)*r11*sj4*sj5))+(((-1.0)*cj4*r12)));
evalcond[2]=((0.006)+(((-1.0)*py))+(((-0.006)*r10*sj5))+(((-0.006)*cj5*r11)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x404=((1.0)*sj5);
IkReal x405=((1.0)*cj5);
IkReal x406=((((-1.0)*r00*sj4*x405))+((r01*sj4*sj5))+((cj4*r02)));
j3eval[0]=x406;
j3eval[1]=IKsign(x406);
j3eval[2]=((IKabs(((((-1.0)*r20*x404))+(((-1.0)*r21*x405)))))+(IKabs((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*r21*x404))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x407=((1.0)*r01);
IkReal x408=((1.0)*sj5);
IkReal x409=(((cj5*r20*sj4))+(((-1.0)*r21*sj4*x408))+(((-1.0)*cj4*r22)));
j3eval[0]=x409;
j3eval[1]=((IKabs((((r02*sj4))+(((-1.0)*cj4*sj5*x407))+((cj4*cj5*r00)))))+(IKabs(((((-1.0)*cj5*x407))+(((-1.0)*r00*x408))))));
j3eval[2]=IKsign(x409);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x410=cj4*cj4;
IkReal x411=r10*r10;
IkReal x412=cj5*cj5;
IkReal x413=r11*r11;
IkReal x414=r12*r12;
IkReal x415=(r11*sj5);
IkReal x416=((1.0)*r10);
IkReal x417=(r12*sj4);
IkReal x418=((1.0)*x410);
IkReal x419=((2.0)*cj5*r10);
IkReal x420=(x412*x413);
IkReal x421=(x411*x412);
IkReal x422=((((-1.0)*x421))+((x410*x421))+((x415*x419))+((x410*x413))+(((-1.0)*x410*x415*x419))+x411+x414+x420+(((-2.0)*cj4*x415*x417))+(((-1.0)*x418*x420))+((cj4*x417*x419))+(((-1.0)*x414*x418)));
j3eval[0]=x422;
j3eval[1]=IKsign(x422);
j3eval[2]=((IKabs(((((-1.0)*cj4*cj5*x416))+((cj4*x415))+(((-1.0)*x417)))))+(IKabs(((((-1.0)*cj5*r11))+(((-1.0)*sj5*x416))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x423=cj4*cj4;
IkReal x424=r10*r10;
IkReal x425=cj5*cj5;
IkReal x426=r11*r11;
IkReal x427=r12*r12;
IkReal x428=(r11*sj5);
IkReal x429=((1.0)*cj5);
IkReal x430=(r12*sj4);
IkReal x431=((1.0)*x423);
IkReal x432=((2.0)*cj5*r10);
IkReal x433=(x425*x426);
IkReal x434=(x424*x425);
CheckValue<IkReal> x435=IKPowWithIntegerCheck(IKsign(((((-1.0)*x423*x428*x432))+(((-1.0)*x427*x431))+(((-1.0)*x434))+((x428*x432))+(((-1.0)*x431*x433))+((cj4*x430*x432))+x427+x424+x433+((x423*x434))+(((-2.0)*cj4*x428*x430))+((x423*x426)))),-1);
if(!x435.valid){
continue;
}
CheckValue<IkReal> x436 = IKatan2WithCheck(IkReal(((((-1.0)*x430))+((cj4*x428))+(((-1.0)*cj4*r10*x429)))),((((-1.0)*r10*sj5))+(((-1.0)*r11*x429))),IKFAST_ATAN2_MAGTHRESH);
if(!x436.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x435.value)))+(x436.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x437=IKsin(j3);
IkReal x438=IKcos(j3);
IkReal x439=(r10*sj5);
IkReal x440=(cj4*sj5);
IkReal x441=(cj5*r11);
IkReal x442=(cj4*cj5);
IkReal x443=(r12*sj4);
IkReal x444=((1.0)*x438);
IkReal x445=((1.0)*x437);
evalcond[0]=(((r11*x438*x440))+(((-1.0)*x443*x444))+((x437*x439))+((x437*x441))+(((-1.0)*r10*x442*x444)));
evalcond[1]=(((r21*x437*x440))+(((-1.0)*cj5*r21*x444))+(((-1.0)*r22*sj4*x445))+(((-1.0)*r20*sj5*x444))+(((-1.0)*r20*x442*x445)));
evalcond[2]=((((-1.0)*r00*x442*x445))+(((-1.0)*cj5*r01*x444))+(((-1.0)*r00*sj5*x444))+(((-1.0)*r02*sj4*x445))+((r01*x437*x440)));
evalcond[3]=((-1.0)+(((-1.0)*x439*x444))+(((-1.0)*x443*x445))+((r11*x437*x440))+(((-1.0)*r10*x442*x445))+(((-1.0)*x441*x444)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x446=((12.0)*pz);
IkReal x447=(cj5*sj4);
IkReal x448=(cj4*r02);
IkReal x449=(cj4*r22);
IkReal x450=(cj5*r21);
IkReal x451=(sj4*sj5);
IkReal x452=(r20*sj5);
IkReal x453=((0.072)*x452);
IkReal x454=((0.072)*x450);
IkReal x455=((3.096)*x449);
IkReal x456=((0.36)*x448);
IkReal x457=((0.36)*r01*x451);
IkReal x458=((3.096)*r21*x451);
IkReal x459=((((3.096)*r20*x447))+(((0.36)*r00*x447)));
IkReal x460=(x446+x458+x456+x457+x454+x455+x453);
j1eval[0]=((1.0)+(((1.04173611574105)*(IKabs(((-1.056)+(((-1.0)*x459))+x460)))))+(((1.04173611574105)*(IKabs(((1.056)+(((-1.0)*x459))+x460)))))+(((1.04173611574105)*(IKabs(((-1.056)+(((4.0)*pz))+(((1.032)*x449))+(((0.12)*x448))+(((-0.12)*r00*x447))+(((0.024)*x450))+(((0.024)*x452))+(((-1.032)*r20*x447))+(((0.12)*r01*x451))+(((1.032)*r21*x451))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x461=((12.0)*pz);
IkReal x462=((4.0)*pz);
IkReal x463=(cj4*r02);
IkReal x464=((3.096)*sj4);
IkReal x465=(cj5*r20);
IkReal x466=(cj5*r21);
IkReal x467=(r21*sj5);
IkReal x468=(r20*sj5);
IkReal x469=((0.12)*sj4);
IkReal x470=(cj5*r00);
IkReal x471=(r01*sj5);
IkReal x472=(cj4*r22);
IkReal x473=((0.36)*sj4);
IkReal x474=((1.032)*sj4);
IkReal x475=((0.072)*x468);
IkReal x476=((0.072)*x466);
IkReal x477=((3.096)*x472);
IkReal x478=((0.36)*x463);
IkReal x479=((0.12)*x463);
IkReal x480=((0.024)*x466);
IkReal x481=((1.032)*x472);
IkReal x482=((0.024)*x468);
IkReal x483=(x471*x473);
IkReal x484=(x464*x467);
IkReal x485=(x469*x471);
IkReal x486=(x467*x474);
IkReal x487=(((x470*x473))+((x464*x465)));
IkReal x488=(((x469*x470))+((x465*x474)));
IkReal x489=(x483+x484+x461+x475+x476+x477+x478);
IkReal x490=(x481+x480+x482+x485+x486+x462+x479);
op[0]=((-1.056)+(((-1.0)*x488))+x490);
op[1]=0.239984;
op[2]=((-1.056)+(((-1.0)*x487))+x489);
op[3]=0.479968;
op[4]=((1.056)+(((-1.0)*x487))+x489);
op[5]=0.239984;
op[6]=((1.056)+(((-1.0)*x488))+x490);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x491=((4.0)*pz);
IkReal x492=(r21*sj5);
IkReal x493=(cj5*r21);
IkReal x494=(cj5*r20);
IkReal x495=(cj4*r22);
IkReal x496=((1.032)*sj4);
IkReal x497=((3.096)*sj4);
IkReal x498=((0.36)*cj3);
IkReal x499=(r22*sj4);
IkReal x500=((0.12)*sj3);
IkReal x501=((0.36)*sj3);
IkReal x502=(r20*sj5);
IkReal x503=((0.024)*x493);
IkReal x504=((1.032)*x495);
IkReal x505=((0.024)*x502);
IkReal x506=((0.12)*cj3*cj4);
IkReal x507=(x494*x496);
IkReal x508=(x493*x500);
IkReal x509=(x493*x501);
IkReal x510=(x494*x497);
IkReal x511=(x501*x502);
IkReal x512=(x500*x502);
IkReal x513=((0.12)*cj3*x499);
IkReal x514=(x492*x496);
IkReal x515=(cj4*x492*x498);
IkReal x516=(x492*x506);
IkReal x517=(x494*x506);
IkReal x518=(x508+x507+x516+x512);
IkReal x519=(x509+x515+x511+x510);
IkReal x520=((((0.072)*x502))+(((12.0)*pz))+((cj4*x494*x498))+(((0.072)*x493))+(((3.096)*x495))+((x498*x499))+((x492*x497)));
IkReal x521=(x491+x503+x504+x505+x517+x514+x513);
j1evalpoly[0]=((-1.056)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((1.056)+(((-1.0)*x521))+x518))))+(((-0.479968)*(htj1*htj1*htj1)))+(((-1.0)*x521))+(((-0.239984)*htj1))+x518+(((htj1*htj1)*(((-1.056)+(((-1.0)*x520))+x519))))+(((htj1*htj1*htj1*htj1)*(((1.056)+(((-1.0)*x520))+x519))))+(((-0.239984)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x522=((1.0)*r01);
IkReal x523=(sj1*sj4);
IkReal x524=(cj5*r00);
IkReal x525=(cj1*cj4);
IkReal x526=(cj5*r20);
IkReal x527=(cj1*sj4);
IkReal x528=(sj5*x527);
IkReal x529=((1.0)*cj4*sj1);
if( IKabs(((((-1.0)*r02*x525))+((x524*x527))+((x523*x526))+(((-1.0)*r21*sj5*x523))+(((-1.0)*x522*x528))+(((-1.0)*r22*x529)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x526*x527))+((r21*x528))+((r22*x525))+(((-1.0)*r02*x529))+((x523*x524))+(((-1.0)*sj5*x522*x523)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r02*x525))+((x524*x527))+((x523*x526))+(((-1.0)*r21*sj5*x523))+(((-1.0)*x522*x528))+(((-1.0)*r22*x529))))+IKsqr(((((-1.0)*x526*x527))+((r21*x528))+((r22*x525))+(((-1.0)*r02*x529))+((x523*x524))+(((-1.0)*sj5*x522*x523))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r02*x525))+((x524*x527))+((x523*x526))+(((-1.0)*r21*sj5*x523))+(((-1.0)*x522*x528))+(((-1.0)*r22*x529))), ((((-1.0)*x526*x527))+((r21*x528))+((r22*x525))+(((-1.0)*r02*x529))+((x523*x524))+(((-1.0)*sj5*x522*x523))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x530=IKcos(j2);
IkReal x531=IKsin(j2);
IkReal x532=((0.258)*sj1);
IkReal x533=((1.0)*cj3);
IkReal x534=(cj5*r00);
IkReal x535=(cj5*r01);
IkReal x536=(cj5*r21);
IkReal x537=(cj5*r20);
IkReal x538=(r00*sj5);
IkReal x539=((1.0)*cj4);
IkReal x540=(r20*sj5);
IkReal x541=(cj1*x530);
IkReal x542=(cj3*cj4*sj5);
IkReal x543=(sj1*x530);
IkReal x544=((1.0)*sj4*sj5);
IkReal x545=(cj1*x531);
IkReal x546=(sj1*x531);
IkReal x547=((1.0)*x543);
IkReal x548=((1.0)*x545);
IkReal x549=(x547+x548);
evalcond[0]=((((-1.0)*r22*x539))+(((-1.0)*x546))+(((-1.0)*r21*x544))+x541+((sj4*x537)));
evalcond[1]=((((-1.0)*x549))+(((-1.0)*r02*x539))+(((-1.0)*r01*x544))+((sj4*x534)));
evalcond[2]=((((-1.0)*x541))+((sj3*x535))+((sj3*x538))+(((-1.0)*cj4*x533*x534))+x546+(((-1.0)*r02*sj4*x533))+((r01*x542)));
evalcond[3]=(((r21*x542))+((sj3*x540))+((sj3*x536))+(((-1.0)*cj4*x533*x537))+(((-1.0)*x549))+(((-1.0)*r22*sj4*x533)));
evalcond[4]=((((0.03)*x545))+(((0.03)*x543))+(((-0.029998)*sj1))+(((-0.258)*x541))+(((-0.006)*x536))+(((-0.006)*x540))+((x531*x532))+(((-1.0)*pz))+(((-0.264)*cj1)));
evalcond[5]=((((0.03)*x541))+(((0.264)*sj1))+(((-0.006)*x538))+(((-0.006)*x535))+(((-0.029998)*cj1))+(((-1.0)*px))+(((-0.03)*x546))+((x530*x532))+(((0.258)*x545)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x550=((1.0)*r01);
IkReal x551=((1.0)*sj5);
CheckValue<IkReal> x552=IKPowWithIntegerCheck(IKsign((((cj5*r20*sj4))+(((-1.0)*r21*sj4*x551))+(((-1.0)*cj4*r22)))),-1);
if(!x552.valid){
continue;
}
CheckValue<IkReal> x553 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*x550))+(((-1.0)*r00*x551)))),(((r02*sj4))+((cj4*cj5*r00))+(((-1.0)*cj4*sj5*x550))),IKFAST_ATAN2_MAGTHRESH);
if(!x553.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x552.value)))+(x553.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x554=IKsin(j3);
IkReal x555=IKcos(j3);
IkReal x556=(r10*sj5);
IkReal x557=(cj4*sj5);
IkReal x558=(cj5*r11);
IkReal x559=(cj4*cj5);
IkReal x560=(r12*sj4);
IkReal x561=((1.0)*x555);
IkReal x562=((1.0)*x554);
evalcond[0]=(((x554*x558))+((x554*x556))+(((-1.0)*r10*x559*x561))+(((-1.0)*x560*x561))+((r11*x555*x557)));
evalcond[1]=((((-1.0)*cj5*r21*x561))+(((-1.0)*r20*x559*x562))+((r21*x554*x557))+(((-1.0)*r22*sj4*x562))+(((-1.0)*r20*sj5*x561)));
evalcond[2]=(((r01*x554*x557))+(((-1.0)*r00*x559*x562))+(((-1.0)*cj5*r01*x561))+(((-1.0)*r00*sj5*x561))+(((-1.0)*r02*sj4*x562)));
evalcond[3]=((-1.0)+((r11*x554*x557))+(((-1.0)*x558*x561))+(((-1.0)*x556*x561))+(((-1.0)*r10*x559*x562))+(((-1.0)*x560*x562)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x563=((12.0)*pz);
IkReal x564=(cj5*sj4);
IkReal x565=(cj4*r02);
IkReal x566=(cj4*r22);
IkReal x567=(cj5*r21);
IkReal x568=(sj4*sj5);
IkReal x569=(r20*sj5);
IkReal x570=((0.072)*x569);
IkReal x571=((0.072)*x567);
IkReal x572=((3.096)*x566);
IkReal x573=((0.36)*x565);
IkReal x574=((0.36)*r01*x568);
IkReal x575=((3.096)*r21*x568);
IkReal x576=((((0.36)*r00*x564))+(((3.096)*r20*x564)));
IkReal x577=(x575+x574+x571+x570+x573+x572+x563);
j1eval[0]=((1.0)+(((1.04173611574105)*(IKabs(((-1.056)+(((-1.0)*x576))+x577)))))+(((1.04173611574105)*(IKabs(((-1.056)+(((-0.12)*r00*x564))+(((0.12)*r01*x568))+(((-1.032)*r20*x564))+(((0.12)*x565))+(((4.0)*pz))+(((1.032)*r21*x568))+(((0.024)*x569))+(((0.024)*x567))+(((1.032)*x566)))))))+(((1.04173611574105)*(IKabs(((1.056)+(((-1.0)*x576))+x577))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x578=((12.0)*pz);
IkReal x579=((4.0)*pz);
IkReal x580=(cj4*r02);
IkReal x581=((3.096)*sj4);
IkReal x582=(cj5*r20);
IkReal x583=(cj5*r21);
IkReal x584=(r21*sj5);
IkReal x585=(r20*sj5);
IkReal x586=((0.12)*sj4);
IkReal x587=(cj5*r00);
IkReal x588=(r01*sj5);
IkReal x589=(cj4*r22);
IkReal x590=((0.36)*sj4);
IkReal x591=((1.032)*sj4);
IkReal x592=((0.072)*x585);
IkReal x593=((0.072)*x583);
IkReal x594=((3.096)*x589);
IkReal x595=((0.36)*x580);
IkReal x596=((0.12)*x580);
IkReal x597=((0.024)*x583);
IkReal x598=((1.032)*x589);
IkReal x599=((0.024)*x585);
IkReal x600=(x588*x590);
IkReal x601=(x581*x584);
IkReal x602=(x586*x588);
IkReal x603=(x584*x591);
IkReal x604=(((x581*x582))+((x587*x590)));
IkReal x605=(((x586*x587))+((x582*x591)));
IkReal x606=(x578+x595+x594+x593+x592+x601+x600);
IkReal x607=(x579+x597+x596+x599+x598+x603+x602);
op[0]=((-1.056)+x607+(((-1.0)*x605)));
op[1]=0.239984;
op[2]=((-1.056)+x606+(((-1.0)*x604)));
op[3]=0.479968;
op[4]=((1.056)+x606+(((-1.0)*x604)));
op[5]=0.239984;
op[6]=((1.056)+x607+(((-1.0)*x605)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x608=((4.0)*pz);
IkReal x609=(r21*sj5);
IkReal x610=(cj5*r21);
IkReal x611=(cj5*r20);
IkReal x612=(cj4*r22);
IkReal x613=((1.032)*sj4);
IkReal x614=((3.096)*sj4);
IkReal x615=((0.36)*cj3);
IkReal x616=(r22*sj4);
IkReal x617=((0.12)*sj3);
IkReal x618=((0.36)*sj3);
IkReal x619=(r20*sj5);
IkReal x620=((0.024)*x610);
IkReal x621=((1.032)*x612);
IkReal x622=((0.024)*x619);
IkReal x623=((0.12)*cj3*cj4);
IkReal x624=(x611*x613);
IkReal x625=(x610*x617);
IkReal x626=(x610*x618);
IkReal x627=(x611*x614);
IkReal x628=(x618*x619);
IkReal x629=(x617*x619);
IkReal x630=((0.12)*cj3*x616);
IkReal x631=(x609*x613);
IkReal x632=(cj4*x609*x615);
IkReal x633=(x609*x623);
IkReal x634=(x611*x623);
IkReal x635=(x625+x624+x629+x633);
IkReal x636=(x627+x626+x628+x632);
IkReal x637=((((3.096)*x612))+(((12.0)*pz))+((cj4*x611*x615))+((x615*x616))+((x609*x614))+(((0.072)*x619))+(((0.072)*x610)));
IkReal x638=(x608+x621+x620+x622+x634+x630+x631);
j1evalpoly[0]=((-1.056)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((1.056)+(((-1.0)*x638))+x635))))+(((htj1*htj1)*(((-1.056)+(((-1.0)*x637))+x636))))+(((htj1*htj1*htj1*htj1)*(((1.056)+(((-1.0)*x637))+x636))))+(((-0.479968)*(htj1*htj1*htj1)))+(((-1.0)*x638))+(((-0.239984)*htj1))+x635+(((-0.239984)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x639=((1.0)*r01);
IkReal x640=(sj1*sj4);
IkReal x641=(cj5*r00);
IkReal x642=(cj1*cj4);
IkReal x643=(cj5*r20);
IkReal x644=(cj1*sj4);
IkReal x645=(sj5*x644);
IkReal x646=((1.0)*cj4*sj1);
if( IKabs(((((-1.0)*x639*x645))+((x640*x643))+(((-1.0)*r02*x642))+(((-1.0)*r22*x646))+((x641*x644))+(((-1.0)*r21*sj5*x640)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x640*x641))+(((-1.0)*r02*x646))+(((-1.0)*x643*x644))+((r21*x645))+((r22*x642))+(((-1.0)*sj5*x639*x640)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x639*x645))+((x640*x643))+(((-1.0)*r02*x642))+(((-1.0)*r22*x646))+((x641*x644))+(((-1.0)*r21*sj5*x640))))+IKsqr((((x640*x641))+(((-1.0)*r02*x646))+(((-1.0)*x643*x644))+((r21*x645))+((r22*x642))+(((-1.0)*sj5*x639*x640))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x639*x645))+((x640*x643))+(((-1.0)*r02*x642))+(((-1.0)*r22*x646))+((x641*x644))+(((-1.0)*r21*sj5*x640))), (((x640*x641))+(((-1.0)*r02*x646))+(((-1.0)*x643*x644))+((r21*x645))+((r22*x642))+(((-1.0)*sj5*x639*x640))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x647=IKcos(j2);
IkReal x648=IKsin(j2);
IkReal x649=((0.258)*sj1);
IkReal x650=((1.0)*cj3);
IkReal x651=(cj5*r00);
IkReal x652=(cj5*r01);
IkReal x653=(cj5*r21);
IkReal x654=(cj5*r20);
IkReal x655=(r00*sj5);
IkReal x656=((1.0)*cj4);
IkReal x657=(r20*sj5);
IkReal x658=(cj1*x647);
IkReal x659=(cj3*cj4*sj5);
IkReal x660=(sj1*x647);
IkReal x661=((1.0)*sj4*sj5);
IkReal x662=(cj1*x648);
IkReal x663=(sj1*x648);
IkReal x664=((1.0)*x660);
IkReal x665=((1.0)*x662);
IkReal x666=(x665+x664);
evalcond[0]=(((sj4*x654))+(((-1.0)*r21*x661))+(((-1.0)*r22*x656))+(((-1.0)*x663))+x658);
evalcond[1]=(((sj4*x651))+(((-1.0)*r01*x661))+(((-1.0)*x666))+(((-1.0)*r02*x656)));
evalcond[2]=((((-1.0)*x658))+((sj3*x652))+((sj3*x655))+x663+(((-1.0)*r02*sj4*x650))+((r01*x659))+(((-1.0)*cj4*x650*x651)));
evalcond[3]=(((sj3*x653))+((sj3*x657))+(((-1.0)*x666))+(((-1.0)*r22*sj4*x650))+((r21*x659))+(((-1.0)*cj4*x650*x654)));
evalcond[4]=((((-0.258)*x658))+((x648*x649))+(((-0.029998)*sj1))+(((-0.006)*x657))+(((-0.006)*x653))+(((-1.0)*pz))+(((0.03)*x662))+(((0.03)*x660))+(((-0.264)*cj1)));
evalcond[5]=((((-0.03)*x663))+(((0.03)*x658))+(((0.264)*sj1))+(((-0.006)*x655))+(((-0.006)*x652))+(((0.258)*x662))+(((-0.029998)*cj1))+(((-1.0)*px))+((x647*x649)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x667=((1.0)*cj5);
IkReal x668=((1.0)*sj5);
CheckValue<IkReal> x669 = IKatan2WithCheck(IkReal(((((-1.0)*r21*x667))+(((-1.0)*r20*x668)))),((((-1.0)*cj4*r21*x668))+((r22*sj4))+((cj4*cj5*r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x669.valid){
continue;
}
CheckValue<IkReal> x670=IKPowWithIntegerCheck(IKsign(((((-1.0)*r00*sj4*x667))+((r01*sj4*sj5))+((cj4*r02)))),-1);
if(!x670.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x669.value)+(((1.5707963267949)*(x670.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x671=IKsin(j3);
IkReal x672=IKcos(j3);
IkReal x673=(r10*sj5);
IkReal x674=(cj4*sj5);
IkReal x675=(cj5*r11);
IkReal x676=(cj4*cj5);
IkReal x677=(r12*sj4);
IkReal x678=((1.0)*x672);
IkReal x679=((1.0)*x671);
evalcond[0]=(((x671*x673))+((x671*x675))+((r11*x672*x674))+(((-1.0)*x677*x678))+(((-1.0)*r10*x676*x678)));
evalcond[1]=((((-1.0)*r22*sj4*x679))+(((-1.0)*r20*sj5*x678))+(((-1.0)*cj5*r21*x678))+((r21*x671*x674))+(((-1.0)*r20*x676*x679)));
evalcond[2]=((((-1.0)*r00*x676*x679))+(((-1.0)*r00*sj5*x678))+((r01*x671*x674))+(((-1.0)*cj5*r01*x678))+(((-1.0)*r02*sj4*x679)));
evalcond[3]=((-1.0)+(((-1.0)*x675*x678))+(((-1.0)*x677*x679))+(((-1.0)*x673*x678))+((r11*x671*x674))+(((-1.0)*r10*x676*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x680=((12.0)*pz);
IkReal x681=(cj5*sj4);
IkReal x682=(cj4*r02);
IkReal x683=(cj4*r22);
IkReal x684=(cj5*r21);
IkReal x685=(sj4*sj5);
IkReal x686=(r20*sj5);
IkReal x687=((0.072)*x686);
IkReal x688=((0.072)*x684);
IkReal x689=((3.096)*x683);
IkReal x690=((0.36)*x682);
IkReal x691=((0.36)*r01*x685);
IkReal x692=((3.096)*r21*x685);
IkReal x693=((((3.096)*r20*x681))+(((0.36)*r00*x681)));
IkReal x694=(x689+x688+x680+x687+x690+x691+x692);
j1eval[0]=((1.0)+(((1.04173611574105)*(IKabs(((-1.056)+x694+(((-1.0)*x693)))))))+(((1.04173611574105)*(IKabs(((-1.056)+(((4.0)*pz))+(((1.032)*r21*x685))+(((1.032)*x683))+(((-1.032)*r20*x681))+(((0.12)*r01*x685))+(((0.024)*x686))+(((0.024)*x684))+(((-0.12)*r00*x681))+(((0.12)*x682)))))))+(((1.04173611574105)*(IKabs(((1.056)+x694+(((-1.0)*x693))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x695=((12.0)*pz);
IkReal x696=((4.0)*pz);
IkReal x697=(cj4*r02);
IkReal x698=((3.096)*sj4);
IkReal x699=(cj5*r20);
IkReal x700=(cj5*r21);
IkReal x701=(r21*sj5);
IkReal x702=(r20*sj5);
IkReal x703=((0.12)*sj4);
IkReal x704=(cj5*r00);
IkReal x705=(r01*sj5);
IkReal x706=(cj4*r22);
IkReal x707=((0.36)*sj4);
IkReal x708=((1.032)*sj4);
IkReal x709=((0.072)*x702);
IkReal x710=((0.072)*x700);
IkReal x711=((3.096)*x706);
IkReal x712=((0.36)*x697);
IkReal x713=((0.12)*x697);
IkReal x714=((0.024)*x700);
IkReal x715=((1.032)*x706);
IkReal x716=((0.024)*x702);
IkReal x717=(x705*x707);
IkReal x718=(x698*x701);
IkReal x719=(x703*x705);
IkReal x720=(x701*x708);
IkReal x721=(((x704*x707))+((x698*x699)));
IkReal x722=(((x703*x704))+((x699*x708)));
IkReal x723=(x695+x718+x711+x710+x712+x717+x709);
IkReal x724=(x696+x719+x713+x715+x714+x716+x720);
op[0]=((-1.056)+(((-1.0)*x722))+x724);
op[1]=0.239984;
op[2]=((-1.056)+(((-1.0)*x721))+x723);
op[3]=0.479968;
op[4]=((1.056)+(((-1.0)*x721))+x723);
op[5]=0.239984;
op[6]=((1.056)+(((-1.0)*x722))+x724);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x725=((4.0)*pz);
IkReal x726=(r21*sj5);
IkReal x727=(cj5*r21);
IkReal x728=(cj5*r20);
IkReal x729=(cj4*r22);
IkReal x730=((1.032)*sj4);
IkReal x731=((3.096)*sj4);
IkReal x732=((0.36)*cj3);
IkReal x733=(r22*sj4);
IkReal x734=((0.12)*sj3);
IkReal x735=((0.36)*sj3);
IkReal x736=(r20*sj5);
IkReal x737=((0.024)*x727);
IkReal x738=((1.032)*x729);
IkReal x739=((0.024)*x736);
IkReal x740=((0.12)*cj3*cj4);
IkReal x741=(x728*x730);
IkReal x742=(x727*x734);
IkReal x743=(x727*x735);
IkReal x744=(x728*x731);
IkReal x745=(x735*x736);
IkReal x746=(x734*x736);
IkReal x747=((0.12)*cj3*x733);
IkReal x748=(x726*x730);
IkReal x749=(cj4*x726*x732);
IkReal x750=(x726*x740);
IkReal x751=(x728*x740);
IkReal x752=(x750+x746+x742+x741);
IkReal x753=(x744+x745+x743+x749);
IkReal x754=((((0.072)*x736))+(((0.072)*x727))+(((12.0)*pz))+(((3.096)*x729))+((cj4*x728*x732))+((x726*x731))+((x732*x733)));
IkReal x755=(x737+x739+x738+x725+x751+x747+x748);
j1evalpoly[0]=((-1.056)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((1.056)+x752+(((-1.0)*x755))))))+(((htj1*htj1*htj1*htj1)*(((1.056)+x753+(((-1.0)*x754))))))+(((-0.479968)*(htj1*htj1*htj1)))+(((htj1*htj1)*(((-1.056)+x753+(((-1.0)*x754))))))+(((-0.239984)*htj1))+x752+(((-1.0)*x755))+(((-0.239984)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x756=((1.0)*r01);
IkReal x757=(sj1*sj4);
IkReal x758=(cj5*r00);
IkReal x759=(cj1*cj4);
IkReal x760=(cj5*r20);
IkReal x761=(cj1*sj4);
IkReal x762=(sj5*x761);
IkReal x763=((1.0)*cj4*sj1);
if( IKabs((((x757*x760))+(((-1.0)*x756*x762))+(((-1.0)*r02*x759))+((x758*x761))+(((-1.0)*r21*sj5*x757))+(((-1.0)*r22*x763)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r22*x759))+((r21*x762))+(((-1.0)*sj5*x756*x757))+(((-1.0)*r02*x763))+((x757*x758))+(((-1.0)*x760*x761)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x757*x760))+(((-1.0)*x756*x762))+(((-1.0)*r02*x759))+((x758*x761))+(((-1.0)*r21*sj5*x757))+(((-1.0)*r22*x763))))+IKsqr((((r22*x759))+((r21*x762))+(((-1.0)*sj5*x756*x757))+(((-1.0)*r02*x763))+((x757*x758))+(((-1.0)*x760*x761))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x757*x760))+(((-1.0)*x756*x762))+(((-1.0)*r02*x759))+((x758*x761))+(((-1.0)*r21*sj5*x757))+(((-1.0)*r22*x763))), (((r22*x759))+((r21*x762))+(((-1.0)*sj5*x756*x757))+(((-1.0)*r02*x763))+((x757*x758))+(((-1.0)*x760*x761))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x764=IKcos(j2);
IkReal x765=IKsin(j2);
IkReal x766=((0.258)*sj1);
IkReal x767=((1.0)*cj3);
IkReal x768=(cj5*r00);
IkReal x769=(cj5*r01);
IkReal x770=(cj5*r21);
IkReal x771=(cj5*r20);
IkReal x772=(r00*sj5);
IkReal x773=((1.0)*cj4);
IkReal x774=(r20*sj5);
IkReal x775=(cj1*x764);
IkReal x776=(cj3*cj4*sj5);
IkReal x777=(sj1*x764);
IkReal x778=((1.0)*sj4*sj5);
IkReal x779=(cj1*x765);
IkReal x780=(sj1*x765);
IkReal x781=((1.0)*x777);
IkReal x782=((1.0)*x779);
IkReal x783=(x782+x781);
evalcond[0]=(((sj4*x771))+(((-1.0)*r22*x773))+x775+(((-1.0)*x780))+(((-1.0)*r21*x778)));
evalcond[1]=((((-1.0)*x783))+(((-1.0)*r02*x773))+((sj4*x768))+(((-1.0)*r01*x778)));
evalcond[2]=(((sj3*x769))+((r01*x776))+((sj3*x772))+(((-1.0)*cj4*x767*x768))+x780+(((-1.0)*x775))+(((-1.0)*r02*sj4*x767)));
evalcond[3]=((((-1.0)*cj4*x767*x771))+(((-1.0)*x783))+(((-1.0)*r22*sj4*x767))+((r21*x776))+((sj3*x770))+((sj3*x774)));
evalcond[4]=((((-0.006)*x774))+(((-0.006)*x770))+(((-0.029998)*sj1))+(((-1.0)*pz))+(((-0.264)*cj1))+((x765*x766))+(((-0.258)*x775))+(((0.03)*x777))+(((0.03)*x779)));
evalcond[5]=((((-0.006)*x769))+(((-0.006)*x772))+(((-0.03)*x780))+(((0.264)*sj1))+(((0.258)*x779))+(((-0.029998)*cj1))+(((-1.0)*px))+((x764*x766))+(((0.03)*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5)));
evalcond[2]=((0.006)+(((-0.006)*r00*sj5))+(((-1.0)*px))+(((-0.006)*cj5*r01)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x784=((1.0)*r11);
IkReal x785=(((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)));
j3eval[0]=x785;
j3eval[1]=IKsign(x785);
j3eval[2]=((IKabs(((((-1.0)*r10*sj5))+(((-1.0)*cj5*x784)))))+(IKabs((((cj4*cj5*r10))+((r12*sj4))+(((-1.0)*cj4*sj5*x784))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x786=((1.0)*sj5);
IkReal x787=(((cj5*r10*sj4))+(((-1.0)*r11*sj4*x786))+(((-1.0)*cj4*r12)));
j3eval[0]=x787;
j3eval[1]=((IKabs(((((-1.0)*r20*x786))+(((-1.0)*cj5*r21)))))+(IKabs((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*r21*x786))))));
j3eval[2]=IKsign(x787);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x788=r00*r00;
IkReal x789=cj5*cj5;
IkReal x790=cj4*cj4;
IkReal x791=r01*r01;
IkReal x792=r02*r02;
IkReal x793=(cj5*r00);
IkReal x794=(r02*sj4);
IkReal x795=((2.0)*r01*sj5);
IkReal x796=((1.0)*x790);
IkReal x797=(x788*x789);
IkReal x798=(x789*x791);
IkReal x799=((((-1.0)*x796*x798))+(((-1.0)*x792*x796))+(((-1.0)*cj4*x794*x795))+((x790*x791))+((x790*x797))+(((2.0)*cj4*x793*x794))+((x793*x795))+x792+x798+x788+(((-1.0)*x797))+(((-1.0)*x790*x793*x795)));
j3eval[0]=x799;
j3eval[1]=((IKabs(((((-1.0)*cj4*x793))+(((-1.0)*x794))+((cj4*r01*sj5)))))+(IKabs(((((-1.0)*r00*sj5))+(((-1.0)*cj5*r01))))));
j3eval[2]=IKsign(x799);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x800=r00*r00;
IkReal x801=cj5*cj5;
IkReal x802=cj4*cj4;
IkReal x803=r01*r01;
IkReal x804=r02*r02;
IkReal x805=(cj5*r00);
IkReal x806=(r02*sj4);
IkReal x807=((2.0)*r01*sj5);
IkReal x808=((1.0)*x802);
IkReal x809=(x800*x801);
IkReal x810=(x801*x803);
CheckValue<IkReal> x811=IKPowWithIntegerCheck(IKsign(((((-1.0)*x809))+(((-1.0)*x804*x808))+(((-1.0)*x808*x810))+(((2.0)*cj4*x805*x806))+(((-1.0)*x802*x805*x807))+((x805*x807))+(((-1.0)*cj4*x806*x807))+x810+x804+x800+((x802*x809))+((x802*x803)))),-1);
if(!x811.valid){
continue;
}
CheckValue<IkReal> x812 = IKatan2WithCheck(IkReal(((((-1.0)*x806))+((cj4*r01*sj5))+(((-1.0)*cj4*x805)))),((((-1.0)*r00*sj5))+(((-1.0)*cj5*r01))),IKFAST_ATAN2_MAGTHRESH);
if(!x812.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x811.value)))+(x812.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x813=IKsin(j3);
IkReal x814=IKcos(j3);
IkReal x815=(r02*sj4);
IkReal x816=(cj4*cj5);
IkReal x817=(cj4*sj5);
IkReal x818=(cj5*r01);
IkReal x819=(r00*sj5);
IkReal x820=((1.0)*x814);
IkReal x821=((1.0)*x813);
evalcond[0]=(((r01*x814*x817))+(((-1.0)*x815*x820))+((x813*x818))+((x813*x819))+(((-1.0)*r00*x816*x820)));
evalcond[1]=((((-1.0)*r22*sj4*x821))+(((-1.0)*r20*x816*x821))+((r21*x813*x817))+(((-1.0)*cj5*r21*x820))+(((-1.0)*r20*sj5*x820)));
evalcond[2]=(((r11*x813*x817))+(((-1.0)*r10*x816*x821))+(((-1.0)*r12*sj4*x821))+(((-1.0)*r10*sj5*x820))+(((-1.0)*cj5*r11*x820)));
evalcond[3]=((-1.0)+((r01*x813*x817))+(((-1.0)*x818*x820))+(((-1.0)*x819*x820))+(((-1.0)*x815*x821))+(((-1.0)*r00*x816*x821)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x822=(cj5*r21);
IkReal x823=(cj4*r22);
IkReal x824=(cj5*r11);
IkReal x825=(r20*sj5);
IkReal x826=(r10*sj5);
IkReal x827=(r21*sj4*sj5);
IkReal x828=(cj5*r20*sj4);
IkReal x829=((0.809568)*x828);
IkReal x830=((((0.018576)*x822))+(((0.018576)*x825))+(((0.809568)*x827))+(((0.809568)*x823))+(((0.36)*py))+(((0.00216)*x826))+(((0.00216)*x824))+(((3.096)*pz)));
j1eval[0]=((1.0)+(((1.99559576803425)*(IKabs(((0.26884824)+(((-1.0)*x830))+x829)))))+(((1.99559576803425)*(IKabs(((0.26884824)+(((-0.006192)*x825))+(((-0.006192)*x822))+(((-0.269856)*x827))+(((-0.269856)*x823))+(((-0.00072)*x826))+(((-0.00072)*x824))+(((-0.12)*py))+(((0.269856)*x828))+(((-1.032)*pz)))))))+(((1.99559576803425)*(IKabs(((-0.26884824)+(((-1.0)*x830))+x829))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x831=(cj5*r21);
IkReal x832=(cj4*r22);
IkReal x833=(cj5*r11);
IkReal x834=(r20*sj5);
IkReal x835=(r10*sj5);
IkReal x836=(r21*sj4*sj5);
IkReal x837=(cj5*r20*sj4);
IkReal x838=((0.809568)*x837);
IkReal x839=((0.269856)*x837);
IkReal x840=((((0.018576)*x834))+(((0.018576)*x831))+(((0.809568)*x832))+(((0.809568)*x836))+(((0.36)*py))+(((0.00216)*x835))+(((0.00216)*x833))+(((3.096)*pz)));
IkReal x841=((((0.12)*py))+(((0.006192)*x834))+(((0.006192)*x831))+(((1.032)*pz))+(((0.269856)*x836))+(((0.269856)*x832))+(((0.00072)*x835))+(((0.00072)*x833)));
op[0]=((0.26884824)+(((-1.0)*x841))+x839);
op[1]=-0.125275872;
op[2]=((0.26884824)+(((-1.0)*x840))+x838);
op[3]=-0.250551744;
op[4]=((-0.26884824)+(((-1.0)*x840))+x838);
op[5]=-0.125275872;
op[6]=((-0.26884824)+(((-1.0)*x841))+x839);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x842=((0.12)*pz);
IkReal x843=((0.36)*pz);
IkReal x844=((1.032)*py);
IkReal x845=(r10*sj5);
IkReal x846=(cj5*r11);
IkReal x847=(cj5*r21);
IkReal x848=(cj4*r12);
IkReal x849=(r20*sj5);
IkReal x850=((0.00072)*x847);
IkReal x851=((0.00072)*x849);
IkReal x852=((0.00216)*x849);
IkReal x853=((0.00216)*x847);
IkReal x854=((0.269856)*x848);
IkReal x855=((0.006192)*x846);
IkReal x856=((0.006192)*x845);
IkReal x857=(r11*sj4*sj5);
IkReal x858=(cj5*r10*sj4);
IkReal x859=((0.809568)*x858);
IkReal x860=((0.269856)*x858);
IkReal x861=((0.269856)*x857);
IkReal x862=(x852+x853+x859+x843);
IkReal x863=(x850+x851+x860+x842);
IkReal x864=((((0.809568)*x857))+(((3.096)*py))+(((0.809568)*x848))+(((0.018576)*x845))+(((0.018576)*x846)));
IkReal x865=(x856+x854+x855+x861+x844);
j1evalpoly[0]=((0.062637936)+(((-1.0)*x865))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x865))+x863))))+(((htj1*htj1)*(((0.062637936)+(((-1.0)*x864))+x862))))+(((htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x864))+x862))))+(((-0.53769648)*htj1))+(((-1.07539296)*(htj1*htj1*htj1)))+x863+(((-0.53769648)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x866=(cj4*r12);
IkReal x867=(cj4*r22);
IkReal x868=(cj1*sj4);
IkReal x869=(r11*sj5);
IkReal x870=(r21*sj5);
IkReal x871=((1.0)*sj1);
IkReal x872=(sj1*sj4);
IkReal x873=(cj5*r20);
IkReal x874=((1.0)*cj5*r10);
if( IKabs((((x872*x873))+((x868*x869))+(((-1.0)*sj4*x870*x871))+(((-1.0)*x868*x874))+((cj1*x866))+(((-1.0)*x867*x871)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x868*x870))+((sj1*x866))+(((-1.0)*x868*x873))+((cj1*x867))+(((-1.0)*cj5*r10*sj4*x871))+((x869*x872)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x872*x873))+((x868*x869))+(((-1.0)*sj4*x870*x871))+(((-1.0)*x868*x874))+((cj1*x866))+(((-1.0)*x867*x871))))+IKsqr((((x868*x870))+((sj1*x866))+(((-1.0)*x868*x873))+((cj1*x867))+(((-1.0)*cj5*r10*sj4*x871))+((x869*x872))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x872*x873))+((x868*x869))+(((-1.0)*sj4*x870*x871))+(((-1.0)*x868*x874))+((cj1*x866))+(((-1.0)*x867*x871))), (((x868*x870))+((sj1*x866))+(((-1.0)*x868*x873))+((cj1*x867))+(((-1.0)*cj5*r10*sj4*x871))+((x869*x872))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x875=IKcos(j2);
IkReal x876=IKsin(j2);
IkReal x877=(cj3*cj4);
IkReal x878=(r21*sj5);
IkReal x879=((0.258)*sj1);
IkReal x880=((1.0)*sj4);
IkReal x881=((1.0)*cj5);
IkReal x882=((0.006)*cj5);
IkReal x883=(cj5*sj3);
IkReal x884=(cj5*sj4);
IkReal x885=((1.0)*cj4);
IkReal x886=((0.006)*sj5);
IkReal x887=(sj3*sj5);
IkReal x888=(r11*sj5);
IkReal x889=(cj1*x875);
IkReal x890=(sj1*x875);
IkReal x891=(cj1*x876);
IkReal x892=(sj1*x876);
IkReal x893=((1.0)*x892);
evalcond[0]=(((r10*x884))+(((-1.0)*r12*x885))+x890+x891+(((-1.0)*x880*x888)));
evalcond[1]=(((r20*x884))+(((-1.0)*x893))+x889+(((-1.0)*r22*x885))+(((-1.0)*x878*x880)));
evalcond[2]=(((r11*x883))+((r10*x887))+((x877*x888))+(((-1.0)*x893))+(((-1.0)*cj3*r12*x880))+(((-1.0)*r10*x877*x881))+x889);
evalcond[3]=((((-1.0)*r20*x877*x881))+((r20*x887))+(((-1.0)*cj3*r22*x880))+(((-1.0)*x890))+(((-1.0)*x891))+((r21*x883))+((x877*x878)));
evalcond[4]=((((-0.258)*x889))+((x876*x879))+(((-0.029998)*sj1))+(((-1.0)*pz))+(((-0.264)*cj1))+(((0.03)*x891))+(((0.03)*x890))+(((-1.0)*r20*x886))+(((-1.0)*r21*x882)));
evalcond[5]=((((-0.258)*x891))+(((0.029998)*cj1))+(((-0.264)*sj1))+(((-1.0)*r11*x882))+(((-1.0)*py))+(((-1.0)*r10*x886))+(((0.03)*x892))+(((-1.0)*x875*x879))+(((-0.03)*x889)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x894=((1.0)*sj5);
CheckValue<IkReal> x895=IKPowWithIntegerCheck(IKsign((((cj5*r10*sj4))+(((-1.0)*r11*sj4*x894))+(((-1.0)*cj4*r12)))),-1);
if(!x895.valid){
continue;
}
CheckValue<IkReal> x896 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r21))+(((-1.0)*r20*x894)))),(((r22*sj4))+(((-1.0)*cj4*r21*x894))+((cj4*cj5*r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x896.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x895.value)))+(x896.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x897=IKsin(j3);
IkReal x898=IKcos(j3);
IkReal x899=(r02*sj4);
IkReal x900=(cj4*cj5);
IkReal x901=(cj4*sj5);
IkReal x902=(cj5*r01);
IkReal x903=(r00*sj5);
IkReal x904=((1.0)*x898);
IkReal x905=((1.0)*x897);
evalcond[0]=(((r01*x898*x901))+((x897*x903))+((x897*x902))+(((-1.0)*r00*x900*x904))+(((-1.0)*x899*x904)));
evalcond[1]=((((-1.0)*r20*sj5*x904))+(((-1.0)*cj5*r21*x904))+(((-1.0)*r22*sj4*x905))+((r21*x897*x901))+(((-1.0)*r20*x900*x905)));
evalcond[2]=((((-1.0)*cj5*r11*x904))+(((-1.0)*r10*sj5*x904))+(((-1.0)*r10*x900*x905))+((r11*x897*x901))+(((-1.0)*r12*sj4*x905)));
evalcond[3]=((-1.0)+(((-1.0)*x903*x904))+(((-1.0)*x902*x904))+(((-1.0)*r00*x900*x905))+((r01*x897*x901))+(((-1.0)*x899*x905)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x906=(cj5*r21);
IkReal x907=(cj4*r22);
IkReal x908=(cj5*r11);
IkReal x909=(r20*sj5);
IkReal x910=(r10*sj5);
IkReal x911=(r21*sj4*sj5);
IkReal x912=(cj5*r20*sj4);
IkReal x913=((0.809568)*x912);
IkReal x914=((((0.018576)*x906))+(((0.018576)*x909))+(((0.36)*py))+(((0.00216)*x908))+(((0.00216)*x910))+(((0.809568)*x907))+(((0.809568)*x911))+(((3.096)*pz)));
j1eval[0]=((1.0)+(((1.99559576803425)*(IKabs(((0.26884824)+(((-0.269856)*x907))+(((-0.00072)*x910))+(((-0.006192)*x909))+(((-0.006192)*x906))+(((0.269856)*x912))+(((-0.12)*py))+(((-0.00072)*x908))+(((-1.032)*pz))+(((-0.269856)*x911)))))))+(((1.99559576803425)*(IKabs(((-0.26884824)+(((-1.0)*x914))+x913)))))+(((1.99559576803425)*(IKabs(((0.26884824)+(((-1.0)*x914))+x913))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x915=(cj5*r21);
IkReal x916=(cj4*r22);
IkReal x917=(cj5*r11);
IkReal x918=(r20*sj5);
IkReal x919=(r10*sj5);
IkReal x920=(r21*sj4*sj5);
IkReal x921=(cj5*r20*sj4);
IkReal x922=((0.809568)*x921);
IkReal x923=((0.269856)*x921);
IkReal x924=((((0.36)*py))+(((0.018576)*x918))+(((0.018576)*x915))+(((0.00216)*x917))+(((0.00216)*x919))+(((0.809568)*x916))+(((0.809568)*x920))+(((3.096)*pz)));
IkReal x925=((((0.12)*py))+(((0.006192)*x915))+(((0.006192)*x918))+(((0.269856)*x916))+(((1.032)*pz))+(((0.00072)*x919))+(((0.00072)*x917))+(((0.269856)*x920)));
op[0]=((0.26884824)+(((-1.0)*x925))+x923);
op[1]=-0.125275872;
op[2]=((0.26884824)+(((-1.0)*x924))+x922);
op[3]=-0.250551744;
op[4]=((-0.26884824)+(((-1.0)*x924))+x922);
op[5]=-0.125275872;
op[6]=((-0.26884824)+(((-1.0)*x925))+x923);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x926=((0.12)*pz);
IkReal x927=((0.36)*pz);
IkReal x928=((1.032)*py);
IkReal x929=(r10*sj5);
IkReal x930=(cj5*r11);
IkReal x931=(cj5*r21);
IkReal x932=(cj4*r12);
IkReal x933=(r20*sj5);
IkReal x934=((0.00072)*x931);
IkReal x935=((0.00072)*x933);
IkReal x936=((0.00216)*x933);
IkReal x937=((0.00216)*x931);
IkReal x938=((0.269856)*x932);
IkReal x939=((0.006192)*x930);
IkReal x940=((0.006192)*x929);
IkReal x941=(r11*sj4*sj5);
IkReal x942=(cj5*r10*sj4);
IkReal x943=((0.809568)*x942);
IkReal x944=((0.269856)*x942);
IkReal x945=((0.269856)*x941);
IkReal x946=(x937+x936+x927+x943);
IkReal x947=(x935+x934+x926+x944);
IkReal x948=((((0.018576)*x930))+(((0.018576)*x929))+(((0.809568)*x941))+(((0.809568)*x932))+(((3.096)*py)));
IkReal x949=(x939+x938+x928+x940+x945);
j1evalpoly[0]=((0.062637936)+(((-1.0)*x949))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x949))+x947))))+(((htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x948))+x946))))+(((-0.53769648)*htj1))+(((-1.07539296)*(htj1*htj1*htj1)))+x947+(((htj1*htj1)*(((0.062637936)+(((-1.0)*x948))+x946))))+(((-0.53769648)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x950=(cj4*r12);
IkReal x951=(cj4*r22);
IkReal x952=(cj1*sj4);
IkReal x953=(r11*sj5);
IkReal x954=(r21*sj5);
IkReal x955=((1.0)*sj1);
IkReal x956=(sj1*sj4);
IkReal x957=(cj5*r20);
IkReal x958=((1.0)*cj5*r10);
if( IKabs((((x952*x953))+((cj1*x950))+((x956*x957))+(((-1.0)*x951*x955))+(((-1.0)*x952*x958))+(((-1.0)*sj4*x954*x955)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x952*x954))+((cj1*x951))+(((-1.0)*cj5*r10*sj4*x955))+(((-1.0)*x952*x957))+((sj1*x950))+((x953*x956)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x952*x953))+((cj1*x950))+((x956*x957))+(((-1.0)*x951*x955))+(((-1.0)*x952*x958))+(((-1.0)*sj4*x954*x955))))+IKsqr((((x952*x954))+((cj1*x951))+(((-1.0)*cj5*r10*sj4*x955))+(((-1.0)*x952*x957))+((sj1*x950))+((x953*x956))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x952*x953))+((cj1*x950))+((x956*x957))+(((-1.0)*x951*x955))+(((-1.0)*x952*x958))+(((-1.0)*sj4*x954*x955))), (((x952*x954))+((cj1*x951))+(((-1.0)*cj5*r10*sj4*x955))+(((-1.0)*x952*x957))+((sj1*x950))+((x953*x956))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x959=IKcos(j2);
IkReal x960=IKsin(j2);
IkReal x961=(cj3*cj4);
IkReal x962=(r21*sj5);
IkReal x963=((0.258)*sj1);
IkReal x964=((1.0)*sj4);
IkReal x965=((1.0)*cj5);
IkReal x966=((0.006)*cj5);
IkReal x967=(cj5*sj3);
IkReal x968=(cj5*sj4);
IkReal x969=((1.0)*cj4);
IkReal x970=((0.006)*sj5);
IkReal x971=(sj3*sj5);
IkReal x972=(r11*sj5);
IkReal x973=(cj1*x959);
IkReal x974=(sj1*x959);
IkReal x975=(cj1*x960);
IkReal x976=(sj1*x960);
IkReal x977=((1.0)*x976);
evalcond[0]=((((-1.0)*x964*x972))+(((-1.0)*r12*x969))+x975+x974+((r10*x968)));
evalcond[1]=((((-1.0)*x962*x964))+((r20*x968))+(((-1.0)*r22*x969))+x973+(((-1.0)*x977)));
evalcond[2]=(((x961*x972))+(((-1.0)*r10*x961*x965))+((r11*x967))+((r10*x971))+(((-1.0)*cj3*r12*x964))+x973+(((-1.0)*x977)));
evalcond[3]=((((-1.0)*r20*x961*x965))+(((-1.0)*cj3*r22*x964))+(((-1.0)*x975))+(((-1.0)*x974))+((x961*x962))+((r21*x967))+((r20*x971)));
evalcond[4]=((((-1.0)*r20*x970))+(((-1.0)*r21*x966))+(((-0.029998)*sj1))+((x960*x963))+(((-0.258)*x973))+(((-1.0)*pz))+(((-0.264)*cj1))+(((0.03)*x974))+(((0.03)*x975)));
evalcond[5]=((((0.029998)*cj1))+(((-0.264)*sj1))+(((-0.258)*x975))+(((-1.0)*py))+(((-1.0)*x959*x963))+(((-1.0)*r11*x966))+(((0.03)*x976))+(((-0.03)*x973))+(((-1.0)*r10*x970)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x978=((1.0)*r11);
CheckValue<IkReal> x979=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)))),-1);
if(!x979.valid){
continue;
}
CheckValue<IkReal> x980 = IKatan2WithCheck(IkReal(((((-1.0)*r10*sj5))+(((-1.0)*cj5*x978)))),(((cj4*cj5*r10))+((r12*sj4))+(((-1.0)*cj4*sj5*x978))),IKFAST_ATAN2_MAGTHRESH);
if(!x980.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x979.value)))+(x980.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x981=IKsin(j3);
IkReal x982=IKcos(j3);
IkReal x983=(r02*sj4);
IkReal x984=(cj4*cj5);
IkReal x985=(cj4*sj5);
IkReal x986=(cj5*r01);
IkReal x987=(r00*sj5);
IkReal x988=((1.0)*x982);
IkReal x989=((1.0)*x981);
evalcond[0]=(((x981*x987))+((x981*x986))+(((-1.0)*r00*x984*x988))+(((-1.0)*x983*x988))+((r01*x982*x985)));
evalcond[1]=((((-1.0)*r20*sj5*x988))+((r21*x981*x985))+(((-1.0)*r20*x984*x989))+(((-1.0)*cj5*r21*x988))+(((-1.0)*r22*sj4*x989)));
evalcond[2]=(((r11*x981*x985))+(((-1.0)*r10*sj5*x988))+(((-1.0)*r12*sj4*x989))+(((-1.0)*cj5*r11*x988))+(((-1.0)*r10*x984*x989)));
evalcond[3]=((-1.0)+((r01*x981*x985))+(((-1.0)*r00*x984*x989))+(((-1.0)*x986*x988))+(((-1.0)*x987*x988))+(((-1.0)*x983*x989)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x990=(cj5*r21);
IkReal x991=(cj4*r22);
IkReal x992=(cj5*r11);
IkReal x993=(r20*sj5);
IkReal x994=(r10*sj5);
IkReal x995=(r21*sj4*sj5);
IkReal x996=(cj5*r20*sj4);
IkReal x997=((0.809568)*x996);
IkReal x998=((((0.36)*py))+(((0.809568)*x991))+(((0.809568)*x995))+(((0.018576)*x993))+(((0.018576)*x990))+(((3.096)*pz))+(((0.00216)*x994))+(((0.00216)*x992)));
j1eval[0]=((1.0)+(((1.99559576803425)*(IKabs(((0.26884824)+(((0.269856)*x996))+(((-0.006192)*x993))+(((-0.006192)*x990))+(((-0.269856)*x995))+(((-0.269856)*x991))+(((-0.12)*py))+(((-0.00072)*x994))+(((-0.00072)*x992))+(((-1.032)*pz)))))))+(((1.99559576803425)*(IKabs(((-0.26884824)+(((-1.0)*x998))+x997)))))+(((1.99559576803425)*(IKabs(((0.26884824)+(((-1.0)*x998))+x997))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x999=(cj5*r21);
IkReal x1000=(cj4*r22);
IkReal x1001=(cj5*r11);
IkReal x1002=(r20*sj5);
IkReal x1003=(r10*sj5);
IkReal x1004=(r21*sj4*sj5);
IkReal x1005=(cj5*r20*sj4);
IkReal x1006=((0.809568)*x1005);
IkReal x1007=((0.269856)*x1005);
IkReal x1008=((((0.809568)*x1000))+(((0.809568)*x1004))+(((0.36)*py))+(((0.00216)*x1003))+(((0.00216)*x1001))+(((0.018576)*x1002))+(((0.018576)*x999))+(((3.096)*pz)));
IkReal x1009=((((0.12)*py))+(((0.269856)*x1004))+(((0.269856)*x1000))+(((0.00072)*x1003))+(((0.00072)*x1001))+(((1.032)*pz))+(((0.006192)*x999))+(((0.006192)*x1002)));
op[0]=((0.26884824)+x1007+(((-1.0)*x1009)));
op[1]=-0.125275872;
op[2]=((0.26884824)+x1006+(((-1.0)*x1008)));
op[3]=-0.250551744;
op[4]=((-0.26884824)+x1006+(((-1.0)*x1008)));
op[5]=-0.125275872;
op[6]=((-0.26884824)+x1007+(((-1.0)*x1009)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1010=((0.12)*pz);
IkReal x1011=((0.36)*pz);
IkReal x1012=((1.032)*py);
IkReal x1013=(r10*sj5);
IkReal x1014=(cj5*r11);
IkReal x1015=(cj5*r21);
IkReal x1016=(cj4*r12);
IkReal x1017=(r20*sj5);
IkReal x1018=((0.00072)*x1015);
IkReal x1019=((0.00072)*x1017);
IkReal x1020=((0.00216)*x1017);
IkReal x1021=((0.00216)*x1015);
IkReal x1022=((0.269856)*x1016);
IkReal x1023=((0.006192)*x1014);
IkReal x1024=((0.006192)*x1013);
IkReal x1025=(r11*sj4*sj5);
IkReal x1026=(cj5*r10*sj4);
IkReal x1027=((0.809568)*x1026);
IkReal x1028=((0.269856)*x1026);
IkReal x1029=((0.269856)*x1025);
IkReal x1030=(x1011+x1027+x1021+x1020);
IkReal x1031=(x1018+x1019+x1010+x1028);
IkReal x1032=((((0.809568)*x1016))+(((0.018576)*x1014))+(((0.018576)*x1013))+(((0.809568)*x1025))+(((3.096)*py)));
IkReal x1033=(x1012+x1024+x1023+x1022+x1029);
j1evalpoly[0]=((0.062637936)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x1033))+x1031))))+(((-1.0)*x1033))+(((htj1*htj1)*(((0.062637936)+(((-1.0)*x1032))+x1030))))+x1031+(((-0.53769648)*htj1))+(((-1.07539296)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((-0.062637936)+(((-1.0)*x1032))+x1030))))+(((-0.53769648)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1034=(cj4*r12);
IkReal x1035=(cj4*r22);
IkReal x1036=(cj1*sj4);
IkReal x1037=(r11*sj5);
IkReal x1038=(r21*sj5);
IkReal x1039=((1.0)*sj1);
IkReal x1040=(sj1*sj4);
IkReal x1041=(cj5*r20);
IkReal x1042=((1.0)*cj5*r10);
if( IKabs((((x1036*x1037))+(((-1.0)*x1035*x1039))+((x1040*x1041))+(((-1.0)*sj4*x1038*x1039))+((cj1*x1034))+(((-1.0)*x1036*x1042)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1036*x1038))+((x1037*x1040))+(((-1.0)*x1036*x1041))+((sj1*x1034))+(((-1.0)*cj5*r10*sj4*x1039))+((cj1*x1035)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1036*x1037))+(((-1.0)*x1035*x1039))+((x1040*x1041))+(((-1.0)*sj4*x1038*x1039))+((cj1*x1034))+(((-1.0)*x1036*x1042))))+IKsqr((((x1036*x1038))+((x1037*x1040))+(((-1.0)*x1036*x1041))+((sj1*x1034))+(((-1.0)*cj5*r10*sj4*x1039))+((cj1*x1035))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x1036*x1037))+(((-1.0)*x1035*x1039))+((x1040*x1041))+(((-1.0)*sj4*x1038*x1039))+((cj1*x1034))+(((-1.0)*x1036*x1042))), (((x1036*x1038))+((x1037*x1040))+(((-1.0)*x1036*x1041))+((sj1*x1034))+(((-1.0)*cj5*r10*sj4*x1039))+((cj1*x1035))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1043=IKcos(j2);
IkReal x1044=IKsin(j2);
IkReal x1045=(cj3*cj4);
IkReal x1046=(r21*sj5);
IkReal x1047=((0.258)*sj1);
IkReal x1048=((1.0)*sj4);
IkReal x1049=((1.0)*cj5);
IkReal x1050=((0.006)*cj5);
IkReal x1051=(cj5*sj3);
IkReal x1052=(cj5*sj4);
IkReal x1053=((1.0)*cj4);
IkReal x1054=((0.006)*sj5);
IkReal x1055=(sj3*sj5);
IkReal x1056=(r11*sj5);
IkReal x1057=(cj1*x1043);
IkReal x1058=(sj1*x1043);
IkReal x1059=(cj1*x1044);
IkReal x1060=(sj1*x1044);
IkReal x1061=((1.0)*x1060);
evalcond[0]=(x1058+x1059+(((-1.0)*r12*x1053))+((r10*x1052))+(((-1.0)*x1048*x1056)));
evalcond[1]=((((-1.0)*x1046*x1048))+x1057+(((-1.0)*r22*x1053))+((r20*x1052))+(((-1.0)*x1061)));
evalcond[2]=(((r11*x1051))+x1057+(((-1.0)*cj3*r12*x1048))+((r10*x1055))+(((-1.0)*r10*x1045*x1049))+(((-1.0)*x1061))+((x1045*x1056)));
evalcond[3]=((((-1.0)*r20*x1045*x1049))+((r20*x1055))+(((-1.0)*x1058))+(((-1.0)*x1059))+((r21*x1051))+(((-1.0)*cj3*r22*x1048))+((x1045*x1046)));
evalcond[4]=((((0.03)*x1059))+(((0.03)*x1058))+(((-0.029998)*sj1))+(((-1.0)*pz))+(((-0.264)*cj1))+(((-0.258)*x1057))+(((-1.0)*r20*x1054))+(((-1.0)*r21*x1050))+((x1044*x1047)));
evalcond[5]=((((0.03)*x1060))+(((-0.03)*x1057))+(((-1.0)*r10*x1054))+(((0.029998)*cj1))+(((-0.264)*sj1))+(((-1.0)*x1043*x1047))+(((-1.0)*py))+(((-1.0)*r11*x1050))+(((-0.258)*x1059)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5)));
evalcond[2]=((-0.006)+(((-0.006)*r00*sj5))+(((-1.0)*px))+(((-0.006)*cj5*r01)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1062=((1.0)*cj5);
IkReal x1063=((1.0)*sj5);
IkReal x1064=((((-1.0)*r10*sj4*x1062))+((r11*sj4*sj5))+((cj4*r12)));
j3eval[0]=x1064;
j3eval[1]=((IKabs(((((-1.0)*r21*x1062))+(((-1.0)*r20*x1063)))))+(IKabs((((r22*sj4))+(((-1.0)*cj4*r21*x1063))+((cj4*cj5*r20))))));
j3eval[2]=IKsign(x1064);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1065=((1.0)*r11);
IkReal x1066=((1.0)*sj5);
IkReal x1067=((((-1.0)*r21*sj4*x1066))+((cj5*r20*sj4))+(((-1.0)*cj4*r22)));
j3eval[0]=x1067;
j3eval[1]=((IKabs(((((-1.0)*r10*x1066))+(((-1.0)*cj5*x1065)))))+(IKabs((((cj4*cj5*r10))+((r12*sj4))+(((-1.0)*cj4*sj5*x1065))))));
j3eval[2]=IKsign(x1067);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1068=cj4*cj4;
IkReal x1069=cj5*cj5;
IkReal x1070=r01*r01;
IkReal x1071=r02*r02;
IkReal x1072=r00*r00;
IkReal x1073=(cj5*r00);
IkReal x1074=(r01*sj5);
IkReal x1075=(r02*sj4);
IkReal x1076=((2.0)*cj4);
IkReal x1077=((1.0)*x1068);
IkReal x1078=(x1069*x1072);
IkReal x1079=(x1069*x1070);
IkReal x1080=(((x1068*x1071))+((x1068*x1079))+(((-1.0)*x1077*x1078))+x1078+(((-1.0)*x1070*x1077))+(((-2.0)*x1073*x1074))+(((-1.0)*x1073*x1075*x1076))+(((2.0)*x1068*x1073*x1074))+((x1074*x1075*x1076))+(((-1.0)*x1071))+(((-1.0)*x1072))+(((-1.0)*x1079)));
j3eval[0]=x1080;
j3eval[1]=IKsign(x1080);
j3eval[2]=((IKabs(((((-1.0)*r00*sj5))+(((-1.0)*cj5*r01)))))+(IKabs(((((-1.0)*cj4*x1073))+(((-1.0)*x1075))+((cj4*x1074))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1081=cj4*cj4;
IkReal x1082=cj5*cj5;
IkReal x1083=r01*r01;
IkReal x1084=r02*r02;
IkReal x1085=r00*r00;
IkReal x1086=((1.0)*cj5);
IkReal x1087=(cj4*r00);
IkReal x1088=(r02*sj4);
IkReal x1089=((2.0)*cj5);
IkReal x1090=(r00*sj5);
IkReal x1091=((1.0)*x1082);
IkReal x1092=(cj4*r01*sj5);
IkReal x1093=(x1081*x1083);
CheckValue<IkReal> x1094 = IKatan2WithCheck(IkReal((x1092+(((-1.0)*x1088))+(((-1.0)*x1086*x1087)))),((((-1.0)*x1090))+(((-1.0)*r01*x1086))),IKFAST_ATAN2_MAGTHRESH);
if(!x1094.valid){
continue;
}
CheckValue<IkReal> x1095=IKPowWithIntegerCheck(IKsign((((x1082*x1085))+((x1081*x1084))+((r01*x1081*x1089*x1090))+(((-1.0)*r01*x1089*x1090))+(((-1.0)*x1083*x1091))+(((-1.0)*x1093))+(((-1.0)*x1081*x1085*x1091))+(((-1.0)*x1085))+(((-1.0)*x1084))+(((-1.0)*x1087*x1088*x1089))+((x1082*x1093))+(((2.0)*x1088*x1092)))),-1);
if(!x1095.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1094.value)+(((1.5707963267949)*(x1095.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1096=IKsin(j3);
IkReal x1097=IKcos(j3);
IkReal x1098=(r02*sj4);
IkReal x1099=(cj4*cj5);
IkReal x1100=(cj4*sj5);
IkReal x1101=(cj5*r01);
IkReal x1102=(r00*sj5);
IkReal x1103=((1.0)*x1097);
IkReal x1104=((1.0)*x1096);
evalcond[0]=((((-1.0)*x1098*x1103))+((r01*x1097*x1100))+((x1096*x1102))+((x1096*x1101))+(((-1.0)*r00*x1099*x1103)));
evalcond[1]=((((-1.0)*r20*x1099*x1104))+(((-1.0)*r20*sj5*x1103))+((r21*x1096*x1100))+(((-1.0)*r22*sj4*x1104))+(((-1.0)*cj5*r21*x1103)));
evalcond[2]=(((r11*x1096*x1100))+(((-1.0)*r10*x1099*x1104))+(((-1.0)*r10*sj5*x1103))+(((-1.0)*cj5*r11*x1103))+(((-1.0)*r12*sj4*x1104)));
evalcond[3]=((1.0)+(((-1.0)*x1098*x1104))+((r01*x1096*x1100))+(((-1.0)*r00*x1099*x1104))+(((-1.0)*x1102*x1103))+(((-1.0)*x1101*x1103)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1105=((12.0)*pz);
IkReal x1106=((0.36)*sj4);
IkReal x1107=(r11*sj5);
IkReal x1108=(cj5*r10);
IkReal x1109=(cj4*r22);
IkReal x1110=((0.12)*sj4);
IkReal x1111=(cj4*r12);
IkReal x1112=(cj5*r21);
IkReal x1113=(r20*sj5);
IkReal x1114=((0.072)*x1113);
IkReal x1115=((0.072)*x1112);
IkReal x1116=((3.096)*x1109);
IkReal x1117=((0.36)*x1111);
IkReal x1118=(cj5*r20*sj4);
IkReal x1119=(r21*sj4*sj5);
IkReal x1120=(x1106*x1107);
IkReal x1121=((3.096)*x1119);
IkReal x1122=((((3.096)*x1118))+((x1106*x1108)));
IkReal x1123=(x1105+x1115+x1114+x1117+x1116+x1120+x1121);
j1eval[0]=((1.0)+(((1.04173611574105)*(IKabs(((-1.056)+(((4.0)*pz))+(((0.024)*x1113))+(((0.024)*x1112))+(((-1.0)*x1108*x1110))+(((0.12)*x1111))+(((-1.032)*x1118))+(((1.032)*x1119))+(((1.032)*x1109))+((x1107*x1110)))))))+(((1.04173611574105)*(IKabs(((-1.056)+x1123+(((-1.0)*x1122)))))))+(((1.04173611574105)*(IKabs(((1.056)+x1123+(((-1.0)*x1122))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1124=((12.0)*pz);
IkReal x1125=((4.0)*pz);
IkReal x1126=(sj4*sj5);
IkReal x1127=(cj5*sj4);
IkReal x1128=(cj5*r21);
IkReal x1129=(cj4*r22);
IkReal x1130=(r20*sj5);
IkReal x1131=(cj4*r12);
IkReal x1132=((0.072)*x1130);
IkReal x1133=((0.072)*x1128);
IkReal x1134=((3.096)*x1129);
IkReal x1135=((0.36)*x1131);
IkReal x1136=((0.024)*x1128);
IkReal x1137=((1.032)*x1129);
IkReal x1138=((0.024)*x1130);
IkReal x1139=((0.12)*x1131);
IkReal x1140=((0.36)*r11*x1126);
IkReal x1141=((3.096)*r21*x1126);
IkReal x1142=((1.032)*r21*x1126);
IkReal x1143=((0.12)*r11*x1126);
IkReal x1144=((((3.096)*r20*x1127))+(((0.36)*r10*x1127)));
IkReal x1145=((((0.12)*r10*x1127))+(((1.032)*r20*x1127)));
IkReal x1146=(x1142+x1143+x1125+x1139+x1138+x1137+x1136);
IkReal x1147=(x1140+x1141+x1124+x1133+x1132+x1135+x1134);
op[0]=((-1.056)+x1146+(((-1.0)*x1145)));
op[1]=0.239984;
op[2]=((-1.056)+x1147+(((-1.0)*x1144)));
op[3]=0.479968;
op[4]=((1.056)+x1147+(((-1.0)*x1144)));
op[5]=0.239984;
op[6]=((1.056)+x1146+(((-1.0)*x1145)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1148=((4.0)*pz);
IkReal x1149=(r21*sj5);
IkReal x1150=(cj5*r21);
IkReal x1151=(cj5*r20);
IkReal x1152=(cj4*r22);
IkReal x1153=((1.032)*sj4);
IkReal x1154=((3.096)*sj4);
IkReal x1155=((0.36)*cj3);
IkReal x1156=(r22*sj4);
IkReal x1157=((0.12)*sj3);
IkReal x1158=((0.36)*sj3);
IkReal x1159=(r20*sj5);
IkReal x1160=((0.024)*x1150);
IkReal x1161=((1.032)*x1152);
IkReal x1162=((0.024)*x1159);
IkReal x1163=((0.12)*cj3*cj4);
IkReal x1164=(x1151*x1153);
IkReal x1165=(x1150*x1157);
IkReal x1166=(x1150*x1158);
IkReal x1167=(x1151*x1154);
IkReal x1168=(x1158*x1159);
IkReal x1169=(x1157*x1159);
IkReal x1170=((0.12)*cj3*x1156);
IkReal x1171=(x1149*x1153);
IkReal x1172=(cj4*x1149*x1155);
IkReal x1173=(x1149*x1163);
IkReal x1174=(x1151*x1163);
IkReal x1175=(x1164+x1165+x1169+x1173);
IkReal x1176=(x1166+x1167+x1168+x1172);
IkReal x1177=((((0.072)*x1150))+(((0.072)*x1159))+((x1149*x1154))+(((3.096)*x1152))+((cj4*x1151*x1155))+(((12.0)*pz))+((x1155*x1156)));
IkReal x1178=(x1148+x1160+x1161+x1162+x1174+x1171+x1170);
j1evalpoly[0]=((-1.056)+x1175+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((1.056)+x1175+(((-1.0)*x1178))))))+(((-0.479968)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((1.056)+x1176+(((-1.0)*x1177))))))+(((-0.239984)*htj1))+(((-1.0)*x1178))+(((htj1*htj1)*(((-1.056)+x1176+(((-1.0)*x1177))))))+(((-0.239984)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1179=((1.0)*cj1);
IkReal x1180=(sj4*sj5);
IkReal x1181=(cj5*sj4);
IkReal x1182=((1.0)*sj1);
IkReal x1183=(sj1*x1181);
IkReal x1184=(cj4*x1182);
if( IKabs(((((-1.0)*cj4*r12*x1179))+(((-1.0)*r21*x1180*x1182))+((cj1*r10*x1181))+(((-1.0)*r22*x1184))+((r20*x1183))+(((-1.0)*r11*x1179*x1180)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*cj4*r22))+((r10*x1183))+(((-1.0)*r11*x1180*x1182))+((cj1*r21*x1180))+(((-1.0)*r20*x1179*x1181))+(((-1.0)*r12*x1184)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*r12*x1179))+(((-1.0)*r21*x1180*x1182))+((cj1*r10*x1181))+(((-1.0)*r22*x1184))+((r20*x1183))+(((-1.0)*r11*x1179*x1180))))+IKsqr((((cj1*cj4*r22))+((r10*x1183))+(((-1.0)*r11*x1180*x1182))+((cj1*r21*x1180))+(((-1.0)*r20*x1179*x1181))+(((-1.0)*r12*x1184))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj4*r12*x1179))+(((-1.0)*r21*x1180*x1182))+((cj1*r10*x1181))+(((-1.0)*r22*x1184))+((r20*x1183))+(((-1.0)*r11*x1179*x1180))), (((cj1*cj4*r22))+((r10*x1183))+(((-1.0)*r11*x1180*x1182))+((cj1*r21*x1180))+(((-1.0)*r20*x1179*x1181))+(((-1.0)*r12*x1184))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1185=IKcos(j2);
IkReal x1186=IKsin(j2);
IkReal x1187=(cj3*cj4);
IkReal x1188=(r21*sj5);
IkReal x1189=((0.258)*sj1);
IkReal x1190=((1.0)*sj4);
IkReal x1191=((1.0)*cj5);
IkReal x1192=((0.006)*cj5);
IkReal x1193=(cj5*sj3);
IkReal x1194=(cj5*sj4);
IkReal x1195=((1.0)*cj4);
IkReal x1196=((0.006)*sj5);
IkReal x1197=(sj3*sj5);
IkReal x1198=(r11*sj5);
IkReal x1199=(cj1*x1185);
IkReal x1200=(sj1*x1185);
IkReal x1201=(cj1*x1186);
IkReal x1202=(sj1*x1186);
IkReal x1203=((1.0)*x1200);
IkReal x1204=((1.0)*x1201);
IkReal x1205=(x1204+x1203);
evalcond[0]=(x1199+(((-1.0)*x1188*x1190))+(((-1.0)*r22*x1195))+(((-1.0)*x1202))+((r20*x1194)));
evalcond[1]=((((-1.0)*x1190*x1198))+((r10*x1194))+(((-1.0)*x1205))+(((-1.0)*r12*x1195)));
evalcond[2]=((((-1.0)*r10*x1187*x1191))+x1202+((x1187*x1198))+((r10*x1197))+((r11*x1193))+(((-1.0)*cj3*r12*x1190))+(((-1.0)*x1199)));
evalcond[3]=(((x1187*x1188))+(((-1.0)*r20*x1187*x1191))+((r21*x1193))+(((-1.0)*cj3*r22*x1190))+(((-1.0)*x1205))+((r20*x1197)));
evalcond[4]=(((x1186*x1189))+(((-0.029998)*sj1))+(((0.03)*x1201))+(((0.03)*x1200))+(((-1.0)*pz))+(((-0.264)*cj1))+(((-1.0)*r21*x1192))+(((-0.258)*x1199))+(((-1.0)*r20*x1196)));
evalcond[5]=((((-0.03)*x1202))+(((0.264)*sj1))+(((0.258)*x1201))+((x1185*x1189))+(((-1.0)*r10*x1196))+(((-0.029998)*cj1))+(((-1.0)*py))+(((0.03)*x1199))+(((-1.0)*r11*x1192)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1206=((1.0)*r11);
IkReal x1207=((1.0)*sj5);
CheckValue<IkReal> x1208 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1207))+(((-1.0)*cj5*x1206)))),((((-1.0)*cj4*sj5*x1206))+((cj4*cj5*r10))+((r12*sj4))),IKFAST_ATAN2_MAGTHRESH);
if(!x1208.valid){
continue;
}
CheckValue<IkReal> x1209=IKPowWithIntegerCheck(IKsign((((cj5*r20*sj4))+(((-1.0)*r21*sj4*x1207))+(((-1.0)*cj4*r22)))),-1);
if(!x1209.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1208.value)+(((1.5707963267949)*(x1209.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1210=IKsin(j3);
IkReal x1211=IKcos(j3);
IkReal x1212=(r02*sj4);
IkReal x1213=(cj4*cj5);
IkReal x1214=(cj4*sj5);
IkReal x1215=(cj5*r01);
IkReal x1216=(r00*sj5);
IkReal x1217=((1.0)*x1211);
IkReal x1218=((1.0)*x1210);
evalcond[0]=(((x1210*x1215))+((x1210*x1216))+(((-1.0)*r00*x1213*x1217))+(((-1.0)*x1212*x1217))+((r01*x1211*x1214)));
evalcond[1]=((((-1.0)*r20*x1213*x1218))+(((-1.0)*r22*sj4*x1218))+(((-1.0)*cj5*r21*x1217))+((r21*x1210*x1214))+(((-1.0)*r20*sj5*x1217)));
evalcond[2]=((((-1.0)*r10*x1213*x1218))+((r11*x1210*x1214))+(((-1.0)*r12*sj4*x1218))+(((-1.0)*cj5*r11*x1217))+(((-1.0)*r10*sj5*x1217)));
evalcond[3]=((1.0)+((r01*x1210*x1214))+(((-1.0)*x1215*x1217))+(((-1.0)*r00*x1213*x1218))+(((-1.0)*x1216*x1217))+(((-1.0)*x1212*x1218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1219=((12.0)*pz);
IkReal x1220=((0.36)*sj4);
IkReal x1221=(r11*sj5);
IkReal x1222=(cj5*r10);
IkReal x1223=(cj4*r22);
IkReal x1224=((0.12)*sj4);
IkReal x1225=(cj4*r12);
IkReal x1226=(cj5*r21);
IkReal x1227=(r20*sj5);
IkReal x1228=((0.072)*x1227);
IkReal x1229=((0.072)*x1226);
IkReal x1230=((3.096)*x1223);
IkReal x1231=((0.36)*x1225);
IkReal x1232=(cj5*r20*sj4);
IkReal x1233=(r21*sj4*sj5);
IkReal x1234=(x1220*x1221);
IkReal x1235=((3.096)*x1233);
IkReal x1236=(((x1220*x1222))+(((3.096)*x1232)));
IkReal x1237=(x1234+x1235+x1230+x1231+x1229+x1228+x1219);
j1eval[0]=((1.0)+(((1.04173611574105)*(IKabs(((1.056)+x1237+(((-1.0)*x1236)))))))+(((1.04173611574105)*(IKabs(((-1.056)+x1237+(((-1.0)*x1236)))))))+(((1.04173611574105)*(IKabs(((-1.056)+(((4.0)*pz))+(((0.12)*x1225))+(((0.024)*x1227))+(((0.024)*x1226))+(((-1.0)*x1222*x1224))+((x1221*x1224))+(((-1.032)*x1232))+(((1.032)*x1233))+(((1.032)*x1223))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1238=((12.0)*pz);
IkReal x1239=((4.0)*pz);
IkReal x1240=(sj4*sj5);
IkReal x1241=(cj5*sj4);
IkReal x1242=(cj5*r21);
IkReal x1243=(cj4*r22);
IkReal x1244=(r20*sj5);
IkReal x1245=(cj4*r12);
IkReal x1246=((0.072)*x1244);
IkReal x1247=((0.072)*x1242);
IkReal x1248=((3.096)*x1243);
IkReal x1249=((0.36)*x1245);
IkReal x1250=((0.024)*x1242);
IkReal x1251=((1.032)*x1243);
IkReal x1252=((0.024)*x1244);
IkReal x1253=((0.12)*x1245);
IkReal x1254=((0.36)*r11*x1240);
IkReal x1255=((3.096)*r21*x1240);
IkReal x1256=((1.032)*r21*x1240);
IkReal x1257=((0.12)*r11*x1240);
IkReal x1258=((((3.096)*r20*x1241))+(((0.36)*r10*x1241)));
IkReal x1259=((((0.12)*r10*x1241))+(((1.032)*r20*x1241)));
IkReal x1260=(x1256+x1257+x1252+x1253+x1250+x1251+x1239);
IkReal x1261=(x1247+x1246+x1249+x1248+x1254+x1255+x1238);
op[0]=((-1.056)+(((-1.0)*x1259))+x1260);
op[1]=0.239984;
op[2]=((-1.056)+(((-1.0)*x1258))+x1261);
op[3]=0.479968;
op[4]=((1.056)+(((-1.0)*x1258))+x1261);
op[5]=0.239984;
op[6]=((1.056)+(((-1.0)*x1259))+x1260);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1262=((4.0)*pz);
IkReal x1263=(r21*sj5);
IkReal x1264=(cj5*r21);
IkReal x1265=(cj5*r20);
IkReal x1266=(cj4*r22);
IkReal x1267=((1.032)*sj4);
IkReal x1268=((3.096)*sj4);
IkReal x1269=((0.36)*cj3);
IkReal x1270=(r22*sj4);
IkReal x1271=((0.12)*sj3);
IkReal x1272=((0.36)*sj3);
IkReal x1273=(r20*sj5);
IkReal x1274=((0.024)*x1264);
IkReal x1275=((1.032)*x1266);
IkReal x1276=((0.024)*x1273);
IkReal x1277=((0.12)*cj3*cj4);
IkReal x1278=(x1265*x1267);
IkReal x1279=(x1264*x1271);
IkReal x1280=(x1264*x1272);
IkReal x1281=(x1265*x1268);
IkReal x1282=(x1272*x1273);
IkReal x1283=(x1271*x1273);
IkReal x1284=((0.12)*cj3*x1270);
IkReal x1285=(x1263*x1267);
IkReal x1286=(cj4*x1263*x1269);
IkReal x1287=(x1263*x1277);
IkReal x1288=(x1265*x1277);
IkReal x1289=(x1278+x1279+x1287+x1283);
IkReal x1290=(x1286+x1281+x1280+x1282);
IkReal x1291=(((x1269*x1270))+(((12.0)*pz))+(((3.096)*x1266))+((cj4*x1265*x1269))+((x1263*x1268))+(((0.072)*x1264))+(((0.072)*x1273)));
IkReal x1292=(x1274+x1275+x1276+x1262+x1285+x1284+x1288);
j1evalpoly[0]=((-1.056)+x1289+(((-1.0)*x1292))+(((htj1*htj1)*(((-1.056)+x1290+(((-1.0)*x1291))))))+(((-0.479968)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((1.056)+x1290+(((-1.0)*x1291))))))+(((-0.239984)*htj1))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((1.056)+x1289+(((-1.0)*x1292))))))+(((-0.239984)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1293=((1.0)*cj1);
IkReal x1294=(sj4*sj5);
IkReal x1295=(cj5*sj4);
IkReal x1296=((1.0)*sj1);
IkReal x1297=(sj1*x1295);
IkReal x1298=(cj4*x1296);
if( IKabs(((((-1.0)*r11*x1293*x1294))+((cj1*r10*x1295))+((r20*x1297))+(((-1.0)*r21*x1294*x1296))+(((-1.0)*cj4*r12*x1293))+(((-1.0)*r22*x1298)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*cj4*r22))+((cj1*r21*x1294))+(((-1.0)*r20*x1293*x1295))+(((-1.0)*r12*x1298))+(((-1.0)*r11*x1294*x1296))+((r10*x1297)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r11*x1293*x1294))+((cj1*r10*x1295))+((r20*x1297))+(((-1.0)*r21*x1294*x1296))+(((-1.0)*cj4*r12*x1293))+(((-1.0)*r22*x1298))))+IKsqr((((cj1*cj4*r22))+((cj1*r21*x1294))+(((-1.0)*r20*x1293*x1295))+(((-1.0)*r12*x1298))+(((-1.0)*r11*x1294*x1296))+((r10*x1297))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r11*x1293*x1294))+((cj1*r10*x1295))+((r20*x1297))+(((-1.0)*r21*x1294*x1296))+(((-1.0)*cj4*r12*x1293))+(((-1.0)*r22*x1298))), (((cj1*cj4*r22))+((cj1*r21*x1294))+(((-1.0)*r20*x1293*x1295))+(((-1.0)*r12*x1298))+(((-1.0)*r11*x1294*x1296))+((r10*x1297))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1299=IKcos(j2);
IkReal x1300=IKsin(j2);
IkReal x1301=(cj3*cj4);
IkReal x1302=(r21*sj5);
IkReal x1303=((0.258)*sj1);
IkReal x1304=((1.0)*sj4);
IkReal x1305=((1.0)*cj5);
IkReal x1306=((0.006)*cj5);
IkReal x1307=(cj5*sj3);
IkReal x1308=(cj5*sj4);
IkReal x1309=((1.0)*cj4);
IkReal x1310=((0.006)*sj5);
IkReal x1311=(sj3*sj5);
IkReal x1312=(r11*sj5);
IkReal x1313=(cj1*x1299);
IkReal x1314=(sj1*x1299);
IkReal x1315=(cj1*x1300);
IkReal x1316=(sj1*x1300);
IkReal x1317=((1.0)*x1314);
IkReal x1318=((1.0)*x1315);
IkReal x1319=(x1317+x1318);
evalcond[0]=(x1313+(((-1.0)*r22*x1309))+(((-1.0)*x1316))+(((-1.0)*x1302*x1304))+((r20*x1308)));
evalcond[1]=((((-1.0)*x1304*x1312))+((r10*x1308))+(((-1.0)*x1319))+(((-1.0)*r12*x1309)));
evalcond[2]=(x1316+(((-1.0)*x1313))+((r10*x1311))+((r11*x1307))+(((-1.0)*cj3*r12*x1304))+((x1301*x1312))+(((-1.0)*r10*x1301*x1305)));
evalcond[3]=((((-1.0)*cj3*r22*x1304))+(((-1.0)*x1319))+((r21*x1307))+(((-1.0)*r20*x1301*x1305))+((r20*x1311))+((x1301*x1302)));
evalcond[4]=((((-0.029998)*sj1))+((x1300*x1303))+(((-0.258)*x1313))+(((-1.0)*r21*x1306))+(((-1.0)*pz))+(((0.03)*x1314))+(((0.03)*x1315))+(((-1.0)*r20*x1310))+(((-0.264)*cj1)));
evalcond[5]=(((x1299*x1303))+(((0.258)*x1315))+(((0.264)*sj1))+(((-0.029998)*cj1))+(((-1.0)*py))+(((-0.03)*x1316))+(((0.03)*x1313))+(((-1.0)*r11*x1306))+(((-1.0)*r10*x1310)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1320=((1.0)*r21);
CheckValue<IkReal> x1321=IKPowWithIntegerCheck(IKsign((((r11*sj4*sj5))+((cj4*r12))+(((-1.0)*cj5*r10*sj4)))),-1);
if(!x1321.valid){
continue;
}
CheckValue<IkReal> x1322 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*x1320))+(((-1.0)*r20*sj5)))),(((r22*sj4))+(((-1.0)*cj4*sj5*x1320))+((cj4*cj5*r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x1322.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1321.value)))+(x1322.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1323=IKsin(j3);
IkReal x1324=IKcos(j3);
IkReal x1325=(r02*sj4);
IkReal x1326=(cj4*cj5);
IkReal x1327=(cj4*sj5);
IkReal x1328=(cj5*r01);
IkReal x1329=(r00*sj5);
IkReal x1330=((1.0)*x1324);
IkReal x1331=((1.0)*x1323);
evalcond[0]=((((-1.0)*x1325*x1330))+((r01*x1324*x1327))+((x1323*x1328))+((x1323*x1329))+(((-1.0)*r00*x1326*x1330)));
evalcond[1]=(((r21*x1323*x1327))+(((-1.0)*r22*sj4*x1331))+(((-1.0)*r20*sj5*x1330))+(((-1.0)*cj5*r21*x1330))+(((-1.0)*r20*x1326*x1331)));
evalcond[2]=((((-1.0)*r10*x1326*x1331))+(((-1.0)*r12*sj4*x1331))+(((-1.0)*r10*sj5*x1330))+(((-1.0)*cj5*r11*x1330))+((r11*x1323*x1327)));
evalcond[3]=((1.0)+(((-1.0)*x1325*x1331))+(((-1.0)*x1328*x1330))+((r01*x1323*x1327))+(((-1.0)*x1329*x1330))+(((-1.0)*r00*x1326*x1331)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1332=((12.0)*pz);
IkReal x1333=((0.36)*sj4);
IkReal x1334=(r11*sj5);
IkReal x1335=(cj5*r10);
IkReal x1336=(cj4*r22);
IkReal x1337=((0.12)*sj4);
IkReal x1338=(cj4*r12);
IkReal x1339=(cj5*r21);
IkReal x1340=(r20*sj5);
IkReal x1341=((0.072)*x1340);
IkReal x1342=((0.072)*x1339);
IkReal x1343=((3.096)*x1336);
IkReal x1344=((0.36)*x1338);
IkReal x1345=(cj5*r20*sj4);
IkReal x1346=(r21*sj4*sj5);
IkReal x1347=(x1333*x1334);
IkReal x1348=((3.096)*x1346);
IkReal x1349=(((x1333*x1335))+(((3.096)*x1345)));
IkReal x1350=(x1348+x1341+x1342+x1343+x1344+x1347+x1332);
j1eval[0]=((1.0)+(((1.04173611574105)*(IKabs(((1.056)+x1350+(((-1.0)*x1349)))))))+(((1.04173611574105)*(IKabs(((-1.056)+x1350+(((-1.0)*x1349)))))))+(((1.04173611574105)*(IKabs(((-1.056)+(((-1.0)*x1335*x1337))+(((1.032)*x1336))+(((4.0)*pz))+(((1.032)*x1346))+(((0.12)*x1338))+(((0.024)*x1340))+(((-1.032)*x1345))+((x1334*x1337))+(((0.024)*x1339))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1351=((12.0)*pz);
IkReal x1352=((4.0)*pz);
IkReal x1353=(sj4*sj5);
IkReal x1354=(cj5*sj4);
IkReal x1355=(cj5*r21);
IkReal x1356=(cj4*r22);
IkReal x1357=(r20*sj5);
IkReal x1358=(cj4*r12);
IkReal x1359=((0.072)*x1357);
IkReal x1360=((0.072)*x1355);
IkReal x1361=((3.096)*x1356);
IkReal x1362=((0.36)*x1358);
IkReal x1363=((0.024)*x1355);
IkReal x1364=((1.032)*x1356);
IkReal x1365=((0.024)*x1357);
IkReal x1366=((0.12)*x1358);
IkReal x1367=((0.36)*r11*x1353);
IkReal x1368=((3.096)*r21*x1353);
IkReal x1369=((1.032)*r21*x1353);
IkReal x1370=((0.12)*r11*x1353);
IkReal x1371=((((3.096)*r20*x1354))+(((0.36)*r10*x1354)));
IkReal x1372=((((0.12)*r10*x1354))+(((1.032)*r20*x1354)));
IkReal x1373=(x1352+x1366+x1364+x1365+x1363+x1369+x1370);
IkReal x1374=(x1359+x1351+x1367+x1362+x1360+x1361+x1368);
op[0]=((-1.056)+x1373+(((-1.0)*x1372)));
op[1]=0.239984;
op[2]=((-1.056)+x1374+(((-1.0)*x1371)));
op[3]=0.479968;
op[4]=((1.056)+x1374+(((-1.0)*x1371)));
op[5]=0.239984;
op[6]=((1.056)+x1373+(((-1.0)*x1372)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1375=((4.0)*pz);
IkReal x1376=(r21*sj5);
IkReal x1377=(cj5*r21);
IkReal x1378=(cj5*r20);
IkReal x1379=(cj4*r22);
IkReal x1380=((1.032)*sj4);
IkReal x1381=((3.096)*sj4);
IkReal x1382=((0.36)*cj3);
IkReal x1383=(r22*sj4);
IkReal x1384=((0.12)*sj3);
IkReal x1385=((0.36)*sj3);
IkReal x1386=(r20*sj5);
IkReal x1387=((0.024)*x1377);
IkReal x1388=((1.032)*x1379);
IkReal x1389=((0.024)*x1386);
IkReal x1390=((0.12)*cj3*cj4);
IkReal x1391=(x1378*x1380);
IkReal x1392=(x1377*x1384);
IkReal x1393=(x1377*x1385);
IkReal x1394=(x1378*x1381);
IkReal x1395=(x1385*x1386);
IkReal x1396=(x1384*x1386);
IkReal x1397=((0.12)*cj3*x1383);
IkReal x1398=(x1376*x1380);
IkReal x1399=(cj4*x1376*x1382);
IkReal x1400=(x1376*x1390);
IkReal x1401=(x1378*x1390);
IkReal x1402=(x1396+x1392+x1391+x1400);
IkReal x1403=(x1399+x1395+x1394+x1393);
IkReal x1404=((((12.0)*pz))+(((3.096)*x1379))+(((0.072)*x1377))+((x1376*x1381))+((cj4*x1378*x1382))+(((0.072)*x1386))+((x1382*x1383)));
IkReal x1405=(x1375+x1388+x1389+x1387+x1398+x1397+x1401);
j1evalpoly[0]=((-1.056)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((1.056)+(((-1.0)*x1405))+x1402))))+(((-0.479968)*(htj1*htj1*htj1)))+(((-1.0)*x1405))+(((-0.239984)*htj1))+x1402+(((htj1*htj1*htj1*htj1)*(((1.056)+(((-1.0)*x1404))+x1403))))+(((htj1*htj1)*(((-1.056)+(((-1.0)*x1404))+x1403))))+(((-0.239984)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1406=((1.0)*cj1);
IkReal x1407=(sj4*sj5);
IkReal x1408=(cj5*sj4);
IkReal x1409=((1.0)*sj1);
IkReal x1410=(sj1*x1408);
IkReal x1411=(cj4*x1409);
if( IKabs((((r20*x1410))+(((-1.0)*r22*x1411))+(((-1.0)*cj4*r12*x1406))+(((-1.0)*r11*x1406*x1407))+((cj1*r10*x1408))+(((-1.0)*r21*x1407*x1409)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*cj4*r22))+((cj1*r21*x1407))+(((-1.0)*r11*x1407*x1409))+(((-1.0)*r20*x1406*x1408))+(((-1.0)*r12*x1411))+((r10*x1410)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r20*x1410))+(((-1.0)*r22*x1411))+(((-1.0)*cj4*r12*x1406))+(((-1.0)*r11*x1406*x1407))+((cj1*r10*x1408))+(((-1.0)*r21*x1407*x1409))))+IKsqr((((cj1*cj4*r22))+((cj1*r21*x1407))+(((-1.0)*r11*x1407*x1409))+(((-1.0)*r20*x1406*x1408))+(((-1.0)*r12*x1411))+((r10*x1410))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r20*x1410))+(((-1.0)*r22*x1411))+(((-1.0)*cj4*r12*x1406))+(((-1.0)*r11*x1406*x1407))+((cj1*r10*x1408))+(((-1.0)*r21*x1407*x1409))), (((cj1*cj4*r22))+((cj1*r21*x1407))+(((-1.0)*r11*x1407*x1409))+(((-1.0)*r20*x1406*x1408))+(((-1.0)*r12*x1411))+((r10*x1410))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1412=IKcos(j2);
IkReal x1413=IKsin(j2);
IkReal x1414=(cj3*cj4);
IkReal x1415=(r21*sj5);
IkReal x1416=((0.258)*sj1);
IkReal x1417=((1.0)*sj4);
IkReal x1418=((1.0)*cj5);
IkReal x1419=((0.006)*cj5);
IkReal x1420=(cj5*sj3);
IkReal x1421=(cj5*sj4);
IkReal x1422=((1.0)*cj4);
IkReal x1423=((0.006)*sj5);
IkReal x1424=(sj3*sj5);
IkReal x1425=(r11*sj5);
IkReal x1426=(cj1*x1412);
IkReal x1427=(sj1*x1412);
IkReal x1428=(cj1*x1413);
IkReal x1429=(sj1*x1413);
IkReal x1430=((1.0)*x1427);
IkReal x1431=((1.0)*x1428);
IkReal x1432=(x1430+x1431);
evalcond[0]=((((-1.0)*x1415*x1417))+(((-1.0)*x1429))+x1426+(((-1.0)*r22*x1422))+((r20*x1421)));
evalcond[1]=((((-1.0)*x1417*x1425))+(((-1.0)*x1432))+(((-1.0)*r12*x1422))+((r10*x1421)));
evalcond[2]=(((r11*x1420))+(((-1.0)*cj3*r12*x1417))+((x1414*x1425))+(((-1.0)*r10*x1414*x1418))+((r10*x1424))+(((-1.0)*x1426))+x1429);
evalcond[3]=(((r21*x1420))+(((-1.0)*r20*x1414*x1418))+(((-1.0)*cj3*r22*x1417))+(((-1.0)*x1432))+((x1414*x1415))+((r20*x1424)));
evalcond[4]=(((x1413*x1416))+(((-0.029998)*sj1))+(((-1.0)*r20*x1423))+(((-0.258)*x1426))+(((-1.0)*pz))+(((0.03)*x1427))+(((0.03)*x1428))+(((-0.264)*cj1))+(((-1.0)*r21*x1419)));
evalcond[5]=(((x1412*x1416))+(((-1.0)*r10*x1423))+(((0.264)*sj1))+(((0.258)*x1428))+(((-0.029998)*cj1))+(((-1.0)*py))+(((0.03)*x1426))+(((-0.03)*x1429))+(((-1.0)*r11*x1419)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j2, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1433=((1.0)*sj0);
IkReal x1434=(cj4*cj5);
IkReal x1435=(cj0*r00);
IkReal x1436=((1.0)*cj5);
IkReal x1437=(cj4*sj5);
IkReal x1438=(cj0*r01);
CheckValue<IkReal> x1439 = IKatan2WithCheck(IkReal(((((-1.0)*x1436*x1438))+(((-1.0)*sj5*x1435))+(((-1.0)*r10*sj5*x1433))+(((-1.0)*cj5*r11*x1433)))),(((r10*sj0*x1434))+(((-1.0)*r11*x1433*x1437))+((x1434*x1435))+((r12*sj0*sj4))+(((-1.0)*x1437*x1438))+((cj0*r02*sj4))),IKFAST_ATAN2_MAGTHRESH);
if(!x1439.valid){
continue;
}
CheckValue<IkReal> x1440=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*r20*sj4*x1436)))),-1);
if(!x1440.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1439.value)+(((1.5707963267949)*(x1440.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1441=IKsin(j3);
IkReal x1442=IKcos(j3);
IkReal x1443=((1.0)*cj5);
IkReal x1444=(cj4*x1441);
IkReal x1445=((1.0)*sj5*x1442);
IkReal x1446=((1.0)*sj4*x1441);
evalcond[0]=((((-1.0)*r22*x1446))+(((-1.0)*r20*x1445))+((r21*sj5*x1444))+(((-1.0)*r21*x1442*x1443))+(((-1.0)*r20*x1443*x1444)));
evalcond[1]=(cj0+((r11*sj5*x1444))+(((-1.0)*r12*x1446))+(((-1.0)*r10*x1445))+(((-1.0)*r10*x1443*x1444))+(((-1.0)*r11*x1442*x1443)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r00*x1445))+(((-1.0)*r01*x1442*x1443))+(((-1.0)*r00*x1443*x1444))+((r01*sj5*x1444))+(((-1.0)*r02*x1446)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1447=((1.056)*cj0);
IkReal x1448=(cj0*r20);
IkReal x1449=((1.032)*cj0);
IkReal x1450=(cj4*r22);
IkReal x1451=(cj5*sj4);
IkReal x1452=(cj4*r02);
IkReal x1453=(sj4*sj5);
IkReal x1454=(cj0*pz);
IkReal x1455=((3.096)*cj0);
IkReal x1456=((12.0)*x1454);
IkReal x1457=((0.36)*x1452);
IkReal x1458=(cj0*cj5*r21);
IkReal x1459=((0.36)*r00*x1451);
IkReal x1460=((0.072)*x1458);
IkReal x1461=((0.072)*sj5*x1448);
IkReal x1462=(x1450*x1455);
IkReal x1463=((0.36)*r01*x1453);
IkReal x1464=(r21*x1453*x1455);
IkReal x1465=((3.096)*x1448*x1451);
IkReal x1466=(x1465+x1463+x1457);
IkReal x1467=(x1464+x1461+x1460+x1462+x1456+x1459);
j1eval[0]=((((1.04173611574105)*(IKabs(((((-1.0)*x1466))+x1467+(((-1.0)*x1447)))))))+(((1.04173611574105)*(IKabs(((((-1.0)*x1466))+x1467+x1447)))))+(IKabs(cj0))+(((1.04173611574105)*(IKabs(((((4.0)*x1454))+(((0.024)*x1458))+((r21*x1449*x1453))+(((-0.12)*r01*x1453))+(((0.12)*r00*x1451))+(((-0.12)*x1452))+(((0.024)*sj5*x1448))+(((-1.0)*x1447))+(((-1.032)*x1448*x1451))+((x1449*x1450))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1468=((1.056)*cj0);
IkReal x1469=((0.239984)*cj0);
IkReal x1470=(cj0*sj5);
IkReal x1471=((1.032)*sj4);
IkReal x1472=(cj5*sj4);
IkReal x1473=(cj0*r20);
IkReal x1474=(cj4*r02);
IkReal x1475=(cj0*pz);
IkReal x1476=((12.0)*x1475);
IkReal x1477=((0.36)*x1474);
IkReal x1478=((4.0)*x1475);
IkReal x1479=((0.12)*x1474);
IkReal x1480=(cj0*cj4*r22);
IkReal x1481=(cj0*cj5*r21);
IkReal x1482=(r01*sj4*sj5);
IkReal x1483=((0.36)*r00*x1472);
IkReal x1484=((0.072)*x1481);
IkReal x1485=((0.072)*r20*x1470);
IkReal x1486=((3.096)*x1480);
IkReal x1487=((0.36)*x1482);
IkReal x1488=((0.024)*r20*x1470);
IkReal x1489=((0.12)*r00*x1472);
IkReal x1490=((0.024)*x1481);
IkReal x1491=((1.032)*x1480);
IkReal x1492=((0.12)*x1482);
IkReal x1493=((3.096)*r21*sj4*x1470);
IkReal x1494=((3.096)*x1472*x1473);
IkReal x1495=(r21*x1470*x1471);
IkReal x1496=(cj5*x1471*x1473);
IkReal x1497=(x1477+x1494+x1487);
IkReal x1498=(x1479+x1492+x1496);
IkReal x1499=(x1476+x1493+x1483+x1486+x1485+x1484);
IkReal x1500=(x1478+x1490+x1491+x1495+x1489+x1488);
op[0]=((((-1.0)*x1468))+(((-1.0)*x1498))+x1500);
op[1]=x1469;
op[2]=((((-1.0)*x1468))+(((-1.0)*x1497))+x1499);
op[3]=((0.479968)*cj0);
op[4]=((((-1.0)*x1497))+x1468+x1499);
op[5]=x1469;
op[6]=((((-1.0)*x1498))+x1500+x1468);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1501=((1.056)*sj0);
IkReal x1502=(cj5*sj4);
IkReal x1503=((1.032)*sj0);
IkReal x1504=(r21*sj0);
IkReal x1505=(sj4*sj5);
IkReal x1506=((0.239984)*sj0);
IkReal x1507=(cj4*r12);
IkReal x1508=(cj4*r22);
IkReal x1509=((3.096)*sj0);
IkReal x1510=(pz*sj0);
IkReal x1511=((12.0)*x1510);
IkReal x1512=((0.36)*x1507);
IkReal x1513=((4.0)*x1510);
IkReal x1514=((0.12)*x1507);
IkReal x1515=(r20*sj0*sj5);
IkReal x1516=((0.072)*cj5*x1504);
IkReal x1517=(x1508*x1509);
IkReal x1518=((0.36)*r10*x1502);
IkReal x1519=((0.072)*x1515);
IkReal x1520=((0.36)*r11*x1505);
IkReal x1521=((0.024)*x1515);
IkReal x1522=((0.024)*cj5*x1504);
IkReal x1523=(x1503*x1508);
IkReal x1524=((0.12)*r10*x1502);
IkReal x1525=((0.12)*r11*x1505);
IkReal x1526=((3.096)*x1504*x1505);
IkReal x1527=(r20*x1502*x1509);
IkReal x1528=(r21*x1503*x1505);
IkReal x1529=(r20*x1502*x1503);
IkReal x1530=(x1525+x1529+x1514);
IkReal x1531=(x1527+x1520+x1512);
IkReal x1532=(x1524+x1521+x1522+x1523+x1528+x1513);
IkReal x1533=(x1526+x1519+x1518+x1517+x1516+x1511);
j1evalpoly[0]=((((htj1*htj1)*(((((-1.0)*x1531))+x1533+x1501))))+(((-1.0)*x1530))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1501))+(((-1.0)*x1530))+x1532))))+(((0.479968)*sj0*(htj1*htj1*htj1)))+x1532+x1501+((x1506*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x1501))+(((-1.0)*x1531))+x1533))))+((htj1*x1506)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1534=(cj1*sj3);
IkReal x1535=(r20*sj5);
IkReal x1536=((1.0)*r22);
IkReal x1537=(cj1*cj3);
IkReal x1538=(cj5*r21);
IkReal x1539=(cj4*sj1);
IkReal x1540=(cj5*r20);
IkReal x1541=(r21*sj5);
IkReal x1542=(cj1*sj4);
IkReal x1543=(sj1*sj3);
IkReal x1544=(sj1*sj4);
if( IKabs(((((-1.0)*x1541*x1544))+(((-1.0)*sj4*x1536*x1537))+((cj4*x1537*x1541))+((x1540*x1544))+(((-1.0)*cj4*x1537*x1540))+((x1534*x1538))+((x1534*x1535))+(((-1.0)*x1536*x1539)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj3*x1539*x1540))+((cj1*cj4*r22))+((x1538*x1543))+((x1541*x1542))+(((-1.0)*cj3*x1536*x1544))+((cj3*x1539*x1541))+(((-1.0)*x1540*x1542))+((x1535*x1543)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1541*x1544))+(((-1.0)*sj4*x1536*x1537))+((cj4*x1537*x1541))+((x1540*x1544))+(((-1.0)*cj4*x1537*x1540))+((x1534*x1538))+((x1534*x1535))+(((-1.0)*x1536*x1539))))+IKsqr(((((-1.0)*cj3*x1539*x1540))+((cj1*cj4*r22))+((x1538*x1543))+((x1541*x1542))+(((-1.0)*cj3*x1536*x1544))+((cj3*x1539*x1541))+(((-1.0)*x1540*x1542))+((x1535*x1543))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1541*x1544))+(((-1.0)*sj4*x1536*x1537))+((cj4*x1537*x1541))+((x1540*x1544))+(((-1.0)*cj4*x1537*x1540))+((x1534*x1538))+((x1534*x1535))+(((-1.0)*x1536*x1539))), ((((-1.0)*cj3*x1539*x1540))+((cj1*cj4*r22))+((x1538*x1543))+((x1541*x1542))+(((-1.0)*cj3*x1536*x1544))+((cj3*x1539*x1541))+(((-1.0)*x1540*x1542))+((x1535*x1543))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1545=IKsin(j2);
IkReal x1546=IKcos(j2);
IkReal x1547=((0.03)*cj0);
IkReal x1548=((1.0)*cj3);
IkReal x1549=(cj5*r00);
IkReal x1550=((0.258)*cj0);
IkReal x1551=((0.029998)*cj1);
IkReal x1552=(cj4*cj5);
IkReal x1553=(cj5*r01);
IkReal x1554=((0.03)*sj0);
IkReal x1555=((0.006)*cj5);
IkReal x1556=(sj3*sj5);
IkReal x1557=(cj5*sj4);
IkReal x1558=((1.0)*cj4);
IkReal x1559=((0.006)*sj5);
IkReal x1560=((0.264)*sj1);
IkReal x1561=((0.258)*sj0);
IkReal x1562=(cj5*sj3);
IkReal x1563=(cj1*x1546);
IkReal x1564=(sj1*x1545);
IkReal x1565=(cj3*cj4*sj5);
IkReal x1566=(cj1*x1545);
IkReal x1567=(sj1*x1546);
IkReal x1568=((1.0)*sj4*sj5);
evalcond[0]=((((-1.0)*r22*x1558))+x1563+(((-1.0)*r21*x1568))+(((-1.0)*x1564))+((r20*x1557)));
evalcond[1]=((((-1.0)*r02*x1558))+((sj4*x1549))+((cj0*x1567))+((cj0*x1566))+(((-1.0)*r01*x1568)));
evalcond[2]=(((sj0*x1567))+((sj0*x1566))+(((-1.0)*r12*x1558))+(((-1.0)*r11*x1568))+((r10*x1557)));
evalcond[3]=((((-1.0)*r20*x1548*x1552))+((r21*x1565))+((r21*x1562))+(((-1.0)*r22*sj4*x1548))+(((-1.0)*x1566))+(((-1.0)*x1567))+((r20*x1556)));
evalcond[4]=(((r00*x1556))+(((-1.0)*cj0*x1564))+(((-1.0)*cj4*x1548*x1549))+((cj0*x1563))+((sj3*x1553))+(((-1.0)*r02*sj4*x1548))+((r01*x1565)));
evalcond[5]=(((r11*x1562))+((r11*x1565))+(((-1.0)*r12*sj4*x1548))+((sj0*x1563))+(((-1.0)*r10*x1548*x1552))+(((-1.0)*sj0*x1564))+((r10*x1556)));
evalcond[6]=((((0.03)*x1567))+(((0.03)*x1566))+(((-0.029998)*sj1))+(((-0.258)*x1563))+(((0.258)*x1564))+(((-1.0)*pz))+(((-0.264)*cj1))+(((-1.0)*r20*x1559))+(((-1.0)*r21*x1555)));
evalcond[7]=((((-1.0)*cj0*x1560))+((x1547*x1564))+(((-1.0)*px))+(((-1.0)*x1550*x1566))+(((-1.0)*x1550*x1567))+(((-1.0)*x1547*x1563))+(((-0.006)*x1553))+(((-1.0)*r00*x1559))+((cj0*x1551))+(((0.006)*sj0)));
evalcond[8]=((((-0.006)*cj0))+((x1554*x1564))+(((-1.0)*py))+(((-1.0)*sj0*x1560))+(((-1.0)*r11*x1555))+((sj0*x1551))+(((-1.0)*x1554*x1563))+(((-1.0)*x1561*x1567))+(((-1.0)*x1561*x1566))+(((-1.0)*r10*x1559)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1569=((1.0)*sj0);
CheckValue<IkReal> x1570 = IKatan2WithCheck(IkReal(((((-1.0)*r20*sj5*x1569))+(((-1.0)*cj5*r21*x1569)))),((((-1.0)*cj4*r21*sj5*x1569))+((cj4*cj5*r20*sj0))+((r22*sj0*sj4))),IKFAST_ATAN2_MAGTHRESH);
if(!x1570.valid){
continue;
}
CheckValue<IkReal> x1571=IKPowWithIntegerCheck(IKsign((((cj5*r10*sj4))+(((-1.0)*r11*sj4*sj5))+(((-1.0)*cj4*r12)))),-1);
if(!x1571.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1570.value)+(((1.5707963267949)*(x1571.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1572=IKsin(j3);
IkReal x1573=IKcos(j3);
IkReal x1574=((1.0)*cj5);
IkReal x1575=(cj4*x1572);
IkReal x1576=((1.0)*sj5*x1573);
IkReal x1577=((1.0)*sj4*x1572);
evalcond[0]=((((-1.0)*r20*x1574*x1575))+((r21*sj5*x1575))+(((-1.0)*r22*x1577))+(((-1.0)*r21*x1573*x1574))+(((-1.0)*r20*x1576)));
evalcond[1]=(cj0+(((-1.0)*r11*x1573*x1574))+((r11*sj5*x1575))+(((-1.0)*r10*x1576))+(((-1.0)*r10*x1574*x1575))+(((-1.0)*r12*x1577)));
evalcond[2]=((((-1.0)*r02*x1577))+(((-1.0)*sj0))+(((-1.0)*r00*x1574*x1575))+((r01*sj5*x1575))+(((-1.0)*r00*x1576))+(((-1.0)*r01*x1573*x1574)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1578=((1.056)*cj0);
IkReal x1579=(cj0*r20);
IkReal x1580=((1.032)*cj0);
IkReal x1581=(cj4*r22);
IkReal x1582=(cj5*sj4);
IkReal x1583=(cj4*r02);
IkReal x1584=(sj4*sj5);
IkReal x1585=(cj0*pz);
IkReal x1586=((3.096)*cj0);
IkReal x1587=((12.0)*x1585);
IkReal x1588=((0.36)*x1583);
IkReal x1589=(cj0*cj5*r21);
IkReal x1590=((0.36)*r00*x1582);
IkReal x1591=((0.072)*x1589);
IkReal x1592=((0.072)*sj5*x1579);
IkReal x1593=(x1581*x1586);
IkReal x1594=((0.36)*r01*x1584);
IkReal x1595=(r21*x1584*x1586);
IkReal x1596=((3.096)*x1579*x1582);
IkReal x1597=(x1588+x1594+x1596);
IkReal x1598=(x1587+x1595+x1591+x1590+x1593+x1592);
j1eval[0]=((((1.04173611574105)*(IKabs(((((-1.0)*x1597))+x1578+x1598)))))+(IKabs(cj0))+(((1.04173611574105)*(IKabs(((((-0.12)*r01*x1584))+(((0.024)*sj5*x1579))+(((0.024)*x1589))+(((-0.12)*x1583))+((x1580*x1581))+(((0.12)*r00*x1582))+(((4.0)*x1585))+((r21*x1580*x1584))+(((-1.0)*x1578))+(((-1.032)*x1579*x1582)))))))+(((1.04173611574105)*(IKabs(((((-1.0)*x1597))+x1598+(((-1.0)*x1578))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1599=((1.056)*cj0);
IkReal x1600=((0.239984)*cj0);
IkReal x1601=(cj0*sj5);
IkReal x1602=((1.032)*sj4);
IkReal x1603=(cj5*sj4);
IkReal x1604=(cj0*r20);
IkReal x1605=(cj4*r02);
IkReal x1606=(cj0*pz);
IkReal x1607=((12.0)*x1606);
IkReal x1608=((0.36)*x1605);
IkReal x1609=((4.0)*x1606);
IkReal x1610=((0.12)*x1605);
IkReal x1611=(cj0*cj4*r22);
IkReal x1612=(cj0*cj5*r21);
IkReal x1613=(r01*sj4*sj5);
IkReal x1614=((0.36)*r00*x1603);
IkReal x1615=((0.072)*x1612);
IkReal x1616=((0.072)*r20*x1601);
IkReal x1617=((3.096)*x1611);
IkReal x1618=((0.36)*x1613);
IkReal x1619=((0.024)*r20*x1601);
IkReal x1620=((0.12)*r00*x1603);
IkReal x1621=((0.024)*x1612);
IkReal x1622=((1.032)*x1611);
IkReal x1623=((0.12)*x1613);
IkReal x1624=((3.096)*r21*sj4*x1601);
IkReal x1625=((3.096)*x1603*x1604);
IkReal x1626=(r21*x1601*x1602);
IkReal x1627=(cj5*x1602*x1604);
IkReal x1628=(x1625+x1618+x1608);
IkReal x1629=(x1623+x1627+x1610);
IkReal x1630=(x1624+x1616+x1617+x1614+x1615+x1607);
IkReal x1631=(x1622+x1621+x1620+x1626+x1619+x1609);
op[0]=((((-1.0)*x1599))+x1631+(((-1.0)*x1629)));
op[1]=x1600;
op[2]=((((-1.0)*x1599))+x1630+(((-1.0)*x1628)));
op[3]=((0.479968)*cj0);
op[4]=(x1630+(((-1.0)*x1628))+x1599);
op[5]=x1600;
op[6]=(x1631+(((-1.0)*x1629))+x1599);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1632=((1.056)*sj0);
IkReal x1633=(cj5*sj4);
IkReal x1634=((1.032)*sj0);
IkReal x1635=(r21*sj0);
IkReal x1636=(sj4*sj5);
IkReal x1637=((0.239984)*sj0);
IkReal x1638=(cj4*r12);
IkReal x1639=(cj4*r22);
IkReal x1640=((3.096)*sj0);
IkReal x1641=(pz*sj0);
IkReal x1642=((12.0)*x1641);
IkReal x1643=((0.36)*x1638);
IkReal x1644=((4.0)*x1641);
IkReal x1645=((0.12)*x1638);
IkReal x1646=(r20*sj0*sj5);
IkReal x1647=((0.072)*cj5*x1635);
IkReal x1648=(x1639*x1640);
IkReal x1649=((0.36)*r10*x1633);
IkReal x1650=((0.072)*x1646);
IkReal x1651=((0.36)*r11*x1636);
IkReal x1652=((0.024)*x1646);
IkReal x1653=((0.024)*cj5*x1635);
IkReal x1654=(x1634*x1639);
IkReal x1655=((0.12)*r10*x1633);
IkReal x1656=((0.12)*r11*x1636);
IkReal x1657=((3.096)*x1635*x1636);
IkReal x1658=(r20*x1633*x1640);
IkReal x1659=(r21*x1634*x1636);
IkReal x1660=(r20*x1633*x1634);
IkReal x1661=(x1660+x1656+x1645);
IkReal x1662=(x1658+x1651+x1643);
IkReal x1663=(x1659+x1652+x1653+x1654+x1655+x1644);
IkReal x1664=(x1650+x1657+x1647+x1642+x1649+x1648);
j1evalpoly[0]=(((htj1*x1637))+((x1637*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x1663+(((-1.0)*x1632))+(((-1.0)*x1661))))))+x1663+x1632+(((htj1*htj1)*((x1664+x1632+(((-1.0)*x1662))))))+(((htj1*htj1*htj1*htj1)*((x1664+(((-1.0)*x1632))+(((-1.0)*x1662))))))+(((0.479968)*sj0*(htj1*htj1*htj1)))+(((-1.0)*x1661)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1665=(cj1*sj3);
IkReal x1666=(r20*sj5);
IkReal x1667=((1.0)*r22);
IkReal x1668=(cj1*cj3);
IkReal x1669=(cj5*r21);
IkReal x1670=(cj4*sj1);
IkReal x1671=(cj5*r20);
IkReal x1672=(r21*sj5);
IkReal x1673=(cj1*sj4);
IkReal x1674=(sj1*sj3);
IkReal x1675=(sj1*sj4);
if( IKabs(((((-1.0)*x1667*x1670))+(((-1.0)*x1672*x1675))+((cj4*x1668*x1672))+(((-1.0)*sj4*x1667*x1668))+(((-1.0)*cj4*x1668*x1671))+((x1665*x1669))+((x1665*x1666))+((x1671*x1675)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*cj4*r22))+((x1666*x1674))+((cj3*x1670*x1672))+(((-1.0)*x1671*x1673))+(((-1.0)*cj3*x1667*x1675))+((x1669*x1674))+(((-1.0)*cj3*x1670*x1671))+((x1672*x1673)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1667*x1670))+(((-1.0)*x1672*x1675))+((cj4*x1668*x1672))+(((-1.0)*sj4*x1667*x1668))+(((-1.0)*cj4*x1668*x1671))+((x1665*x1669))+((x1665*x1666))+((x1671*x1675))))+IKsqr((((cj1*cj4*r22))+((x1666*x1674))+((cj3*x1670*x1672))+(((-1.0)*x1671*x1673))+(((-1.0)*cj3*x1667*x1675))+((x1669*x1674))+(((-1.0)*cj3*x1670*x1671))+((x1672*x1673))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1667*x1670))+(((-1.0)*x1672*x1675))+((cj4*x1668*x1672))+(((-1.0)*sj4*x1667*x1668))+(((-1.0)*cj4*x1668*x1671))+((x1665*x1669))+((x1665*x1666))+((x1671*x1675))), (((cj1*cj4*r22))+((x1666*x1674))+((cj3*x1670*x1672))+(((-1.0)*x1671*x1673))+(((-1.0)*cj3*x1667*x1675))+((x1669*x1674))+(((-1.0)*cj3*x1670*x1671))+((x1672*x1673))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1676=IKsin(j2);
IkReal x1677=IKcos(j2);
IkReal x1678=((0.03)*cj0);
IkReal x1679=((1.0)*cj3);
IkReal x1680=(cj5*r00);
IkReal x1681=((0.258)*cj0);
IkReal x1682=((0.029998)*cj1);
IkReal x1683=(cj4*cj5);
IkReal x1684=(cj5*r01);
IkReal x1685=((0.03)*sj0);
IkReal x1686=((0.006)*cj5);
IkReal x1687=(sj3*sj5);
IkReal x1688=(cj5*sj4);
IkReal x1689=((1.0)*cj4);
IkReal x1690=((0.006)*sj5);
IkReal x1691=((0.264)*sj1);
IkReal x1692=((0.258)*sj0);
IkReal x1693=(cj5*sj3);
IkReal x1694=(cj1*x1677);
IkReal x1695=(sj1*x1676);
IkReal x1696=(cj3*cj4*sj5);
IkReal x1697=(cj1*x1676);
IkReal x1698=(sj1*x1677);
IkReal x1699=((1.0)*sj4*sj5);
evalcond[0]=((((-1.0)*r21*x1699))+x1694+(((-1.0)*x1695))+(((-1.0)*r22*x1689))+((r20*x1688)));
evalcond[1]=(((sj4*x1680))+((cj0*x1697))+((cj0*x1698))+(((-1.0)*r02*x1689))+(((-1.0)*r01*x1699)));
evalcond[2]=((((-1.0)*r12*x1689))+((sj0*x1697))+((sj0*x1698))+(((-1.0)*r11*x1699))+((r10*x1688)));
evalcond[3]=((((-1.0)*r20*x1679*x1683))+((r21*x1693))+((r21*x1696))+(((-1.0)*x1698))+(((-1.0)*x1697))+(((-1.0)*r22*sj4*x1679))+((r20*x1687)));
evalcond[4]=(((r01*x1696))+(((-1.0)*cj0*x1695))+((r00*x1687))+(((-1.0)*cj4*x1679*x1680))+((cj0*x1694))+((sj3*x1684))+(((-1.0)*r02*sj4*x1679)));
evalcond[5]=(((sj0*x1694))+((r10*x1687))+(((-1.0)*r12*sj4*x1679))+((r11*x1693))+((r11*x1696))+(((-1.0)*r10*x1679*x1683))+(((-1.0)*sj0*x1695)));
evalcond[6]=((((0.258)*x1695))+(((-1.0)*r20*x1690))+(((-0.029998)*sj1))+(((-1.0)*r21*x1686))+(((0.03)*x1697))+(((0.03)*x1698))+(((-1.0)*pz))+(((-0.264)*cj1))+(((-0.258)*x1694)));
evalcond[7]=((((-1.0)*x1681*x1698))+(((-1.0)*x1681*x1697))+(((-1.0)*x1678*x1694))+(((-1.0)*cj0*x1691))+(((-1.0)*px))+(((-0.006)*x1684))+((cj0*x1682))+(((0.006)*sj0))+(((-1.0)*r00*x1690))+((x1678*x1695)));
evalcond[8]=((((-1.0)*x1692*x1698))+(((-1.0)*x1692*x1697))+(((-1.0)*r11*x1686))+(((-1.0)*sj0*x1691))+(((-0.006)*cj0))+((sj0*x1682))+(((-1.0)*py))+((x1685*x1695))+(((-1.0)*r10*x1690))+(((-1.0)*x1685*x1694)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1700=((1.0)*cj0);
CheckValue<IkReal> x1701=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5)))),-1);
if(!x1701.valid){
continue;
}
CheckValue<IkReal> x1702 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r21*x1700))+(((-1.0)*r20*sj5*x1700)))),((((-1.0)*cj4*r21*sj5*x1700))+((cj0*cj4*cj5*r20))+((cj0*r22*sj4))),IKFAST_ATAN2_MAGTHRESH);
if(!x1702.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1701.value)))+(x1702.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1703=IKsin(j3);
IkReal x1704=IKcos(j3);
IkReal x1705=((1.0)*cj5);
IkReal x1706=(cj4*x1703);
IkReal x1707=((1.0)*sj5*x1704);
IkReal x1708=((1.0)*sj4*x1703);
evalcond[0]=((((-1.0)*r20*x1705*x1706))+(((-1.0)*r20*x1707))+((r21*sj5*x1706))+(((-1.0)*r22*x1708))+(((-1.0)*r21*x1704*x1705)));
evalcond[1]=(cj0+(((-1.0)*r10*x1705*x1706))+(((-1.0)*r10*x1707))+((r11*sj5*x1706))+(((-1.0)*r11*x1704*x1705))+(((-1.0)*r12*x1708)));
evalcond[2]=((((-1.0)*sj0))+((r01*sj5*x1706))+(((-1.0)*r02*x1708))+(((-1.0)*r00*x1705*x1706))+(((-1.0)*r00*x1707))+(((-1.0)*r01*x1704*x1705)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1709=((1.056)*cj0);
IkReal x1710=(cj0*r20);
IkReal x1711=((1.032)*cj0);
IkReal x1712=(cj4*r22);
IkReal x1713=(cj5*sj4);
IkReal x1714=(cj4*r02);
IkReal x1715=(sj4*sj5);
IkReal x1716=(cj0*pz);
IkReal x1717=((3.096)*cj0);
IkReal x1718=((12.0)*x1716);
IkReal x1719=((0.36)*x1714);
IkReal x1720=(cj0*cj5*r21);
IkReal x1721=((0.36)*r00*x1713);
IkReal x1722=((0.072)*x1720);
IkReal x1723=((0.072)*sj5*x1710);
IkReal x1724=(x1712*x1717);
IkReal x1725=((0.36)*r01*x1715);
IkReal x1726=(r21*x1715*x1717);
IkReal x1727=((3.096)*x1710*x1713);
IkReal x1728=(x1727+x1725+x1719);
IkReal x1729=(x1726+x1724+x1722+x1723+x1721+x1718);
j1eval[0]=((((1.04173611574105)*(IKabs((x1729+(((-1.0)*x1709))+(((-1.0)*x1728)))))))+(IKabs(cj0))+(((1.04173611574105)*(IKabs((x1729+x1709+(((-1.0)*x1728)))))))+(((1.04173611574105)*(IKabs(((((0.024)*sj5*x1710))+(((-0.12)*x1714))+(((0.12)*r00*x1713))+(((-1.0)*x1709))+(((-0.12)*r01*x1715))+(((4.0)*x1716))+((x1711*x1712))+(((0.024)*x1720))+(((-1.032)*x1710*x1713))+((r21*x1711*x1715))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1730=((1.056)*cj0);
IkReal x1731=((0.239984)*cj0);
IkReal x1732=(cj0*sj5);
IkReal x1733=((1.032)*sj4);
IkReal x1734=(cj5*sj4);
IkReal x1735=(cj0*r20);
IkReal x1736=(cj4*r02);
IkReal x1737=(cj0*pz);
IkReal x1738=((12.0)*x1737);
IkReal x1739=((0.36)*x1736);
IkReal x1740=((4.0)*x1737);
IkReal x1741=((0.12)*x1736);
IkReal x1742=(cj0*cj4*r22);
IkReal x1743=(cj0*cj5*r21);
IkReal x1744=(r01*sj4*sj5);
IkReal x1745=((0.36)*r00*x1734);
IkReal x1746=((0.072)*x1743);
IkReal x1747=((0.072)*r20*x1732);
IkReal x1748=((3.096)*x1742);
IkReal x1749=((0.36)*x1744);
IkReal x1750=((0.024)*r20*x1732);
IkReal x1751=((0.12)*r00*x1734);
IkReal x1752=((0.024)*x1743);
IkReal x1753=((1.032)*x1742);
IkReal x1754=((0.12)*x1744);
IkReal x1755=((3.096)*r21*sj4*x1732);
IkReal x1756=((3.096)*x1734*x1735);
IkReal x1757=(r21*x1732*x1733);
IkReal x1758=(cj5*x1733*x1735);
IkReal x1759=(x1739+x1749+x1756);
IkReal x1760=(x1741+x1758+x1754);
IkReal x1761=(x1738+x1748+x1745+x1746+x1747+x1755);
IkReal x1762=(x1740+x1757+x1753+x1752+x1751+x1750);
op[0]=((((-1.0)*x1760))+x1762+(((-1.0)*x1730)));
op[1]=x1731;
op[2]=(x1761+(((-1.0)*x1759))+(((-1.0)*x1730)));
op[3]=((0.479968)*cj0);
op[4]=(x1730+x1761+(((-1.0)*x1759)));
op[5]=x1731;
op[6]=((((-1.0)*x1760))+x1730+x1762);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1763=((1.056)*sj0);
IkReal x1764=(cj5*sj4);
IkReal x1765=((1.032)*sj0);
IkReal x1766=(r21*sj0);
IkReal x1767=(sj4*sj5);
IkReal x1768=((0.239984)*sj0);
IkReal x1769=(cj4*r12);
IkReal x1770=(cj4*r22);
IkReal x1771=((3.096)*sj0);
IkReal x1772=(pz*sj0);
IkReal x1773=((12.0)*x1772);
IkReal x1774=((0.36)*x1769);
IkReal x1775=((4.0)*x1772);
IkReal x1776=((0.12)*x1769);
IkReal x1777=(r20*sj0*sj5);
IkReal x1778=((0.072)*cj5*x1766);
IkReal x1779=(x1770*x1771);
IkReal x1780=((0.36)*r10*x1764);
IkReal x1781=((0.072)*x1777);
IkReal x1782=((0.36)*r11*x1767);
IkReal x1783=((0.024)*x1777);
IkReal x1784=((0.024)*cj5*x1766);
IkReal x1785=(x1765*x1770);
IkReal x1786=((0.12)*r10*x1764);
IkReal x1787=((0.12)*r11*x1767);
IkReal x1788=((3.096)*x1766*x1767);
IkReal x1789=(r20*x1764*x1771);
IkReal x1790=(r21*x1765*x1767);
IkReal x1791=(r20*x1764*x1765);
IkReal x1792=(x1787+x1791+x1776);
IkReal x1793=(x1789+x1782+x1774);
IkReal x1794=(x1783+x1784+x1785+x1786+x1790+x1775);
IkReal x1795=(x1788+x1780+x1781+x1773+x1779+x1778);
j1evalpoly[0]=((((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1792))+(((-1.0)*x1763))+x1794))))+(((-1.0)*x1792))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x1793))+(((-1.0)*x1763))+x1795))))+x1794+x1763+(((0.479968)*sj0*(htj1*htj1*htj1)))+(((htj1*htj1)*(((((-1.0)*x1793))+x1795+x1763))))+((x1768*(htj1*htj1*htj1*htj1*htj1)))+((htj1*x1768)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1796=(cj1*sj3);
IkReal x1797=(r20*sj5);
IkReal x1798=((1.0)*r22);
IkReal x1799=(cj1*cj3);
IkReal x1800=(cj5*r21);
IkReal x1801=(cj4*sj1);
IkReal x1802=(cj5*r20);
IkReal x1803=(r21*sj5);
IkReal x1804=(cj1*sj4);
IkReal x1805=(sj1*sj3);
IkReal x1806=(sj1*sj4);
if( IKabs((((x1802*x1806))+(((-1.0)*x1798*x1801))+(((-1.0)*sj4*x1798*x1799))+((x1796*x1797))+((x1796*x1800))+(((-1.0)*cj4*x1799*x1802))+(((-1.0)*x1803*x1806))+((cj4*x1799*x1803)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*cj4*r22))+((x1800*x1805))+((x1803*x1804))+((x1797*x1805))+(((-1.0)*cj3*x1798*x1806))+(((-1.0)*cj3*x1801*x1802))+((cj3*x1801*x1803))+(((-1.0)*x1802*x1804)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1802*x1806))+(((-1.0)*x1798*x1801))+(((-1.0)*sj4*x1798*x1799))+((x1796*x1797))+((x1796*x1800))+(((-1.0)*cj4*x1799*x1802))+(((-1.0)*x1803*x1806))+((cj4*x1799*x1803))))+IKsqr((((cj1*cj4*r22))+((x1800*x1805))+((x1803*x1804))+((x1797*x1805))+(((-1.0)*cj3*x1798*x1806))+(((-1.0)*cj3*x1801*x1802))+((cj3*x1801*x1803))+(((-1.0)*x1802*x1804))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x1802*x1806))+(((-1.0)*x1798*x1801))+(((-1.0)*sj4*x1798*x1799))+((x1796*x1797))+((x1796*x1800))+(((-1.0)*cj4*x1799*x1802))+(((-1.0)*x1803*x1806))+((cj4*x1799*x1803))), (((cj1*cj4*r22))+((x1800*x1805))+((x1803*x1804))+((x1797*x1805))+(((-1.0)*cj3*x1798*x1806))+(((-1.0)*cj3*x1801*x1802))+((cj3*x1801*x1803))+(((-1.0)*x1802*x1804))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1807=IKsin(j2);
IkReal x1808=IKcos(j2);
IkReal x1809=((0.03)*cj0);
IkReal x1810=((1.0)*cj3);
IkReal x1811=(cj5*r00);
IkReal x1812=((0.258)*cj0);
IkReal x1813=((0.029998)*cj1);
IkReal x1814=(cj4*cj5);
IkReal x1815=(cj5*r01);
IkReal x1816=((0.03)*sj0);
IkReal x1817=((0.006)*cj5);
IkReal x1818=(sj3*sj5);
IkReal x1819=(cj5*sj4);
IkReal x1820=((1.0)*cj4);
IkReal x1821=((0.006)*sj5);
IkReal x1822=((0.264)*sj1);
IkReal x1823=((0.258)*sj0);
IkReal x1824=(cj5*sj3);
IkReal x1825=(cj1*x1808);
IkReal x1826=(sj1*x1807);
IkReal x1827=(cj3*cj4*sj5);
IkReal x1828=(cj1*x1807);
IkReal x1829=(sj1*x1808);
IkReal x1830=((1.0)*sj4*sj5);
evalcond[0]=((((-1.0)*x1826))+(((-1.0)*r21*x1830))+((r20*x1819))+(((-1.0)*r22*x1820))+x1825);
evalcond[1]=(((cj0*x1829))+((cj0*x1828))+(((-1.0)*r01*x1830))+(((-1.0)*r02*x1820))+((sj4*x1811)));
evalcond[2]=((((-1.0)*r12*x1820))+((sj0*x1829))+((sj0*x1828))+((r10*x1819))+(((-1.0)*r11*x1830)));
evalcond[3]=((((-1.0)*r22*sj4*x1810))+(((-1.0)*x1828))+(((-1.0)*x1829))+((r20*x1818))+(((-1.0)*r20*x1810*x1814))+((r21*x1824))+((r21*x1827)));
evalcond[4]=(((cj0*x1825))+((sj3*x1815))+((r01*x1827))+(((-1.0)*cj4*x1810*x1811))+((r00*x1818))+(((-1.0)*r02*sj4*x1810))+(((-1.0)*cj0*x1826)));
evalcond[5]=((((-1.0)*sj0*x1826))+(((-1.0)*r10*x1810*x1814))+(((-1.0)*r12*sj4*x1810))+((sj0*x1825))+((r11*x1827))+((r11*x1824))+((r10*x1818)));
evalcond[6]=((((-0.258)*x1825))+(((-0.029998)*sj1))+(((0.258)*x1826))+(((0.03)*x1828))+(((0.03)*x1829))+(((-1.0)*pz))+(((-0.264)*cj1))+(((-1.0)*r20*x1821))+(((-1.0)*r21*x1817)));
evalcond[7]=(((cj0*x1813))+(((-1.0)*x1812*x1829))+(((-1.0)*x1812*x1828))+(((-0.006)*x1815))+(((-1.0)*x1809*x1825))+(((-1.0)*px))+(((-1.0)*r00*x1821))+(((-1.0)*cj0*x1822))+((x1809*x1826))+(((0.006)*sj0)));
evalcond[8]=((((-0.006)*cj0))+(((-1.0)*r11*x1817))+(((-1.0)*py))+((sj0*x1813))+(((-1.0)*x1823*x1829))+(((-1.0)*x1823*x1828))+(((-1.0)*x1816*x1825))+(((-1.0)*sj0*x1822))+((x1816*x1826))+(((-1.0)*r10*x1821)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - h_arm_urdf (c8647e7d36fd50a901b89db2fc9d0a04)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
